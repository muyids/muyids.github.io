(window.webpackJsonp=window.webpackJsonp||[]).push([[114],{387:function(e,t,s){"use strict";s.r(t);var v=s(14),a=Object(v.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"git-fetch-的参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#git-fetch-的参数"}},[e._v("#")]),e._v(" Git fetch 的参数")]),e._v(" "),t("p",[e._v("我们刚学习了 git push 的参数，很酷的 "),t("code",[e._v("<place>")]),e._v(" 参数，还有用冒号分隔的 refspecs（"),t("code",[e._v("<source>:<destination>")]),e._v("）。 这些参数可以用于 "),t("code",[e._v("git fetch")]),e._v(" 吗？")]),e._v(" "),t("p",[e._v("你猜中了！"),t("code",[e._v("git fetch")]),e._v(" 的参数和 "),t("code",[e._v("git push")]),e._v(" 极其相似。他们的概念是相同的，只是方向相反罢了（因为现在你是下载，而非上传）")]),e._v(" "),t("p",[e._v("让我们逐个讨论下这些概念……")]),e._v(" "),t("h1",{attrs:{id:"place-参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#place-参数"}},[e._v("#")]),e._v(" "),t("code",[e._v("<place>")]),e._v(" 参数")]),e._v(" "),t("p",[e._v("如果你像如下命令这样为 git fetch 设置 的话：")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("git fetch origin foo\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("Git 会到远程仓库的 "),t("code",[e._v("foo")]),e._v(" 分支上，然后获取所有本地不存在的提交，放到本地的 "),t("code",[e._v("o/foo")]),e._v(" 上。")]),e._v(" "),t("p",[e._v("你可能会好奇 —— 为何 Git 会将新提交放到 "),t("code",[e._v("o/foo")]),e._v(" 而不是放到我本地的 foo 分支呢？之前不是说这样的 参数就是同时应用于本地和远程的位置吗？")]),e._v(" "),t("p",[e._v("好吧, 本例中 Git 做了一些特殊处理，因为你可能在 foo 分支上的工作还未完成，你也不想弄乱它。还记得在 "),t("code",[e._v("git fetch")]),e._v(" 课程里我们讲到的吗 —— 它不会更新你的本地的非远程分支, 只是下载提交记录（这样, 你就可以对远程分支进行检查或者合并了）。")]),e._v(" "),t("h1",{attrs:{id:"指定-source-destination"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#指定-source-destination"}},[e._v("#")]),e._v(" 指定 "),t("code",[e._v("<source>:<destination>")])]),e._v(" "),t("p",[e._v("“如果我们指定 "),t("code",[e._v("<source>:<destination>")]),e._v(" 会发生什么呢？”")]),e._v(" "),t("p",[e._v("如果你觉得直接更新本地分支很爽，那你就用冒号分隔的 refspec 吧。不过，你不能在当前检出的分支上干这个事，但是其它分支是可以的。")]),e._v(" "),t("p",[e._v("这里有一点是需要注意的 —— "),t("code",[e._v("source")]),e._v(" 现在指的是远程仓库中的位置，而 "),t("code",[e._v("<destination>")]),e._v(" 才是要放置提交的本地仓库的位置。它与 git push 刚好相反，这是可以讲的通的，因为我们在往相反的方向传送数据。")]),e._v(" "),t("p",[e._v("理论上虽然行的通，但开发人员很少这么做。我在这里介绍它主要是为了从概念上说明 "),t("code",[e._v("fetch")]),e._v(" 和 "),t("code",[e._v("push")]),e._v(" 的相似性，只是方向相反罢了。")]),e._v(" "),t("h1",{attrs:{id:"古怪的-source"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#古怪的-source"}},[e._v("#")]),e._v(" 古怪的 "),t("code",[e._v("<source>")])]),e._v(" "),t("p",[e._v("Git 有两种关于 "),t("code",[e._v("<source>")]),e._v(" 的用法是比较诡异的，即你可以在 git push 或 git fetch 时不指定任何 "),t("code",[e._v("source")]),e._v("，方法就是仅保留冒号和 destination 部分，source 部分留空。")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("git push origin :side")])]),e._v(" "),t("li",[t("code",[e._v("git fetch origin :bugFix")])])]),e._v(" "),t("h2",{attrs:{id:"push-空-到远程仓库"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#push-空-到远程仓库"}},[e._v("#")]),e._v(" push 空 到远程仓库")]),e._v(" "),t("p",[e._v("如果 push 空 到远程仓库会如何呢？它会删除远程仓库中的分支！")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("git push origin :foo\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("就是这样子, 我们通过给 push 传空值 source，成功删除了远程仓库中的 "),t("code",[e._v("foo")]),e._v(" 分支, 这真有意思...")]),e._v(" "),t("h2",{attrs:{id:"fetch-空-到本地"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fetch-空-到本地"}},[e._v("#")]),e._v(" fetch 空 到本地")]),e._v(" "),t("p",[e._v("如果 fetch 空 到本地，会在本地创建一个新分支。")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("git fetch origin :bar\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])])])}),[],!1,null,null,null);t.default=a.exports}}]);