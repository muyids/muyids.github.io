(window.webpackJsonp=window.webpackJsonp||[]).push([[578],{852:function(t,n,s){"use strict";s.r(n);var a=s(14),r=Object(a.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"后缀树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#后缀树"}},[t._v("#")]),t._v(" 后缀树")]),t._v(" "),n("p",[t._v("后缀树（Suffix Tree）是一种高效的字符串数据结构，主要用于解决字符串相关的问题。")]),t._v(" "),n("h2",{attrs:{id:"应用场景"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[t._v("#")]),t._v(" 应用场景")]),t._v(" "),n("p",[t._v("下面列举了一些后缀树的应用：")]),t._v(" "),n("ol",[n("li",[t._v("字符串匹配：后缀树可以用于在一个文本串中查找一个模式串是否出现过，其时间复杂度为 O(m+n)，其中 m 为模式串的长度，n 为文本串的长度。")]),t._v(" "),n("li",[t._v("最长公共子串：给定两个字符串，后缀树可以用于找到它们的最长公共子串。最长公共子串是两个字符串中的最长的相同的子串，其时间复杂度为 O(m+n)，其中 m 和 n 分别是两个字符串的长度。")]),t._v(" "),n("li",[t._v("多模式匹配：后缀树可以用于在一个文本串中查找多个模式串是否出现过，其时间复杂度为 O(m+k)，其中 m 为模式串的总长度，k 为模式串的个数。")]),t._v(" "),n("li",[t._v("DNA 序列比对：后缀树可以用于比对两个 DNA 序列，其时间复杂度为 O(m+n)，其中 m 和 n 分别是两个 DNA 序列的长度。")])])])}),[],!1,null,null,null);n.default=r.exports}}]);