(window.webpackJsonp=window.webpackJsonp||[]).push([[700],{974:function(v,_,e){"use strict";e.r(_);var t=e(14),r=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("设计一个短网址系统(将 长网址 转换成 短网址，方便用户使用 url）")]),v._v(" "),_("p",[v._v("4S 分析法")]),v._v(" "),_("ol",[_("li",[v._v("提问：分析场景，功能，QPS，存储空间 -- Scenario")]),v._v(" "),_("li",[v._v("画图：根据分析结果设计“可行解” -- Service + Storage")]),v._v(" "),_("li",[v._v("进化：研究可能遇到的问题，优化系统 -- Scale")])]),v._v(" "),_("p",[v._v("场景分析")]),v._v(" "),_("ol",[_("li",[v._v("把长网址 转换为 短网址")]),v._v(" "),_("li",[v._v("把短网址 还原为 长网址（给用户，用户通过短网址），并跳转")])]),v._v(" "),_("h2",{attrs:{id:"场景分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#场景分析"}},[v._v("#")]),v._v(" 场景分析")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("询问日活用户量 （数据规模）")]),v._v(" "),_("p",[v._v("微博约 一亿用户（100M = 10^8）")])]),v._v(" "),_("li",[_("p",[v._v("推算产生一条 Tiny Url 的 QPS (写性能分析)")]),v._v(" "),_("p",[v._v("假定每个用户每天发 0.1 条带 Url 的微博")]),v._v(" "),_("p",[v._v("Average Write QPS = 100 M _ 0.1 / 86400 -> 115 QPS\n峰值 Peak Wirte QPS = 125 _ （2 ~ 5） -> 200 ~ 500（考虑到明星结婚之类的新闻，峰值可能更高）")])]),v._v(" "),_("li",[_("p",[v._v("推算点击一条 Tiny Url 的 QPS (读性能分析)")]),v._v(" "),_("p",[v._v("假设平均每个用户每天点击 1 个 Tiny Url\nAvearge Read QPS = 100 M * 1 / 86400 ~= 1K\nPeak Read QPS ~= 2K ~ 5K")])]),v._v(" "),_("li",[_("p",[v._v("推算存储空间")]),v._v(" "),_("p",[v._v("每天产生的 url 数量 100 M _ 0.1 ~= 10M 条\n每一条 url 假设 100bytes, 100 bytes _ 10M 条 = 1000 M bytes = 1 G\n1T 的硬盘可以用 3 年")])])]),v._v(" "),_("h2",{attrs:{id:"服务分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#服务分析"}},[v._v("#")]),v._v(" 服务分析")]),v._v(" "),_("p",[v._v("服务比较简单，只需要设计一个 UrlService Application")]),v._v(" "),_("p",[v._v("函数设计")]),v._v(" "),_("ul",[_("li",[v._v("UrlService.encode(long_url)")]),v._v(" "),_("li",[v._v("UrlService.decode(short_url)\nAPI 设计")])]),v._v(" "),_("p",[v._v("GET /${short_url}")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[v._v("if （not existed) return 404\nreturn a Http redirect response\n")])])]),_("p",[v._v("POST /data/shorten/")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[v._v("Data = {url: http://xxxxlonglong..}\nreturn shorten url\n")])])]),_("h2",{attrs:{id:"算法设计"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#算法设计"}},[v._v("#")]),v._v(" 算法设计")]),v._v(" "),_("p",[v._v("encode 和 decode")]),v._v(" "),_("p",[v._v("算法 1：使用哈希函数（不可行）")]),v._v(" "),_("p",[v._v("比如取 Long Url 的 MD5 的后 6 位\n优点：快\n缺点：很难设计一个没有冲突的哈希算法")]),v._v(" "),_("p",[v._v("算法 2：随机生成+数据库比较去重")]),v._v(" "),_("p",[v._v("随机生成一个 6 位的 short url，如果没有被用过，就绑定到 Long Url")]),v._v(" "),_("p",[v._v("优点: 实现简单\n缺点：生成短网址的速度会随着短网址越来越多变得越来越慢\n算法 3：进制转换")]),v._v(" "),_("p",[v._v("short url 的组成字符包括 0-9，a-z, A-Z,共 62 个，把短网址字符串看做一个 62 进制的数字\n每次发起生成请求，进制数+1\n优点：效率高\n缺点：依赖于全局自增的 ID")]),v._v(" "),_("h2",{attrs:{id:"存储"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#存储"}},[v._v("#")]),v._v(" 存储")]),v._v(" "),_("p",[v._v("是否需要支持 Transaction? 不需要 nosql +1")]),v._v(" "),_("p",[v._v("是否需要丰富的 SQLQuery? 不需要 nosql +1")]),v._v(" "),_("p",[v._v("代码量，是否想偷懒？")]),v._v(" "),_("blockquote",[_("p",[v._v("大多数 Web Framework 和 SQL 数据库兼容得很好\n用 sql 比用 NOSQL 少写很多代码（nodejs 配合 nosql 代码量也很少）\n对 QPS 的要求有多高？ NOSQL 的 QPS 更高")])]),v._v(" "),_("p",[v._v("对 Scalability 的要求多高？")]),v._v(" "),_("blockquote",[_("p",[v._v("SQL 需要码农自己写代码来 Scale")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[v._v("TODO DB如何做Sharding, Replica\n")])])]),_("blockquote",[_("p",[v._v("NOSQL 自动 Sharding, Replica\n是否需要 Sequential ID?自增 ID ？ -- 取决于算法是什么")])]),v._v(" "),_("h2",{attrs:{id:"scale-扩展-优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#scale-扩展-优化"}},[v._v("#")]),v._v(" Scale 扩展&优化")]),v._v(" "),_("p",[v._v("如何加快响应速度？")]),v._v(" "),_("blockquote",[_("p",[v._v("优化服务器访问速度：不同地区使用不同的 web 服务器，通过 DNS 解析不同地区的用户到不同的服务器\n优化数据访问速度：中心化的 Mysql+Distributed Membcached;不同地区做缓存，共享同一个数据库\n数据是否需要长久保存 short Url？比如一年以上没有访问的，是否可以记录最近访问时间，定期删除")])]),v._v(" "),_("p",[v._v("数据库扩展：写操作忙不过来，比如有的人用脚本写")]),v._v(" "),_("blockquote",[_("p",[v._v("表结构足够简单；不能垂直扩展，只能水平扩展；比如三台 db;\n读操作可以用 short mod 3 得到在哪台机器，直接去读\n写操作 long -> short 可以是一对多的关系，每请求一次写，生成一条数据;")])]),v._v(" "),_("h2",{attrs:{id:"一致性哈希算法-consistent-hashing"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一致性哈希算法-consistent-hashing"}},[v._v("#")]),v._v(" 一致性哈希算法（Consistent Hashing）")]),v._v(" "),_("p",[v._v("水平扩展(Horizontal Sharding)的终极武器")]),v._v(" "),_("ul",[_("li",[v._v("水平切分(Horizontal Sharding)：同一张表，比如交易等，划分在不同的机器上")]),v._v(" "),_("li",[v._v("垂直切分（vertical sharding）: 不同的表放在不同的机器上\n不一致性哈希的缺点：")])]),v._v(" "),_("p",[v._v("当取模的底数发生改变时，大部分数据 会发生迁移")]),v._v(" "),_("p",[v._v("简单的一致性哈希算法：")]),v._v(" "),_("ul",[_("li",[v._v("取模的底数取一个很大的数，比如 360")]),v._v(" "),_("li",[v._v("将 360 分配给 n 台机器，每台机器负责一段区间")]),v._v(" "),_("li",[v._v("区间分配信息记录在一张表，存在 web server 上")]),v._v(" "),_("li",[v._v("每次增删改查数据，先查询区间分配表，再操作")]),v._v(" "),_("li",[v._v("新增机器时，查询区间和最大的两台机器，分成三台")])]),v._v(" "),_("p",[v._v("缺陷：")]),v._v(" "),_("ol",[_("li",[v._v("数据分布不均匀；")]),v._v(" "),_("li",[v._v("迁移压力大；新机器的数据只能从两台老机器上获取，导致两台老机器负载压力大\n更实用的一致性哈希")])]),v._v(" "),_("ul",[_("li",[v._v("将整个 hash 区间看做环，环的大小为 2^64-1")]),v._v(" "),_("li",[v._v("将机器和数据都看做环上的点")])])])}),[],!1,null,null,null);_.default=r.exports}}]);