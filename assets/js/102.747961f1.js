(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{374:function(e,v,_){"use strict";_.r(v);var r=_(14),t=Object(r.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"整理提交记录"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#整理提交记录"}},[e._v("#")]),e._v(" 整理提交记录")]),e._v(" "),v("p",[e._v("到现在我们已经学习了 Git 的基础知识 —— 提交、分支以及在提交树上移动。 这些概念涵盖了 Git 90% 的功能，同样也足够满足开发者的日常需求")]),e._v(" "),v("p",[e._v("然而, 剩余的 10% 在处理复杂的工作流时(或者当你陷入困惑时）可能就显得尤为重要了。接下来要讨论的这个话题是“整理提交记录” —— 开发人员有时会说“我想要把这个提交放到这里, 那个提交放到刚才那个提交的后面”, 而接下来就讲的就是它的实现方式，非常清晰、灵活，还很生动。")]),e._v(" "),v("h1",{attrs:{id:"git-cherry-pick"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#git-cherry-pick"}},[e._v("#")]),e._v(" Git Cherry-pick")]),e._v(" "),v("p",[e._v("本系列的第一个命令是 "),v("code",[e._v("git cherry-pick")]),e._v(", 命令形式为:")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("git cherry-pick <提交号>...")])])]),e._v(" "),v("p",[e._v("如果你想将一些提交复制到当前所在的位置（"),v("code",[e._v("HEAD")]),e._v("）下面的话， Cherry-pick 是最直接的方式了。我个人非常喜欢 "),v("code",[e._v("cherry-pick")]),e._v("，因为它特别简单。")]),e._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://muyids.oss-cn-beijing.aliyuncs.com/img/image-20230209160331012.png",alt:"image-20230209160331012"}}),e._v(" "),v("p",[e._v("这里有一个仓库, 我们想将 "),v("code",[e._v("side")]),e._v(" 分支上的工作复制到 "),v("code",[e._v("main")]),e._v(" 分支，你立刻想到了之前学过的 "),v("code",[e._v("rebase")]),e._v(" 了吧？但是咱们还是看看 "),v("code",[e._v("cherry-pick")]),e._v(" 有什么本领吧。")]),e._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("git cherry-pick C2 C4\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br")])]),v("p",[e._v("我们只需要提交记录 "),v("code",[e._v("C2")]),e._v(" 和 "),v("code",[e._v("C4")]),e._v("，所以 Git 就将被它们抓过来放到当前分支下了。")]),e._v(" "),v("p",[v("strong",[e._v("总结：cherry-pick 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上（只要不是 HEAD 上游的提交就没问题）。")])]),e._v(" "),v("h1",{attrs:{id:"交互式的-rebase"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#交互式的-rebase"}},[e._v("#")]),e._v(" 交互式的 rebase")]),e._v(" "),v("p",[e._v("当你知道你所需要的提交记录（"),v("strong",[e._v("并且")]),e._v("还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。")]),e._v(" "),v("p",[e._v("但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了")]),e._v(" "),v("p",[e._v("交互式 rebase 指的是使用带参数 "),v("code",[e._v("--interactive")]),e._v(" 的 rebase 命令, 简写为 "),v("code",[e._v("-i")])]),e._v(" "),v("p",[e._v("如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。")]),e._v(" "),v("p",[e._v("在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件。 考虑到课程的初衷，我弄了一个对话框来模拟这些操作。")]),e._v(" "),v("p",[e._v("当 rebase UI 界面打开时, 你能做 3 件事:")]),e._v(" "),v("ul",[v("li",[e._v("调整提交记录的顺序（通过鼠标拖放来完成）")]),e._v(" "),v("li",[e._v("删除你不想要的提交（通过切换 "),v("code",[e._v("pick")]),e._v(" 的状态来完成，关闭就意味着你不想要这个提交记录）")])])])}),[],!1,null,null,null);v.default=t.exports}}]);