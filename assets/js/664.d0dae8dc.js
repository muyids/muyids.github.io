(window.webpackJsonp=window.webpackJsonp||[]).push([[664],{936:function(v,_,t){"use strict";t.r(_);var s=t(14),r=Object(s.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"广度优先遍历"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#广度优先遍历"}},[v._v("#")]),v._v(" 广度优先遍历")]),v._v(" "),_("p",[v._v("也叫 层遍历，BFS")]),v._v(" "),_("p",[v._v("遍历过程是从上到下，一层一层的，更接近人的思维")]),v._v(" "),_("h2",{attrs:{id:"实现方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实现方式"}},[v._v("#")]),v._v(" 实现方式")]),v._v(" "),_("p",[v._v("BFS 需要 借助 "),_("strong",[v._v("队列")]),v._v(" 来实现")]),v._v(" "),_("h2",{attrs:{id:"应用场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[v._v("#")]),v._v(" 应用场景")]),v._v(" "),_("ul",[_("li",[v._v("求解最短、最小路径问题")]),v._v(" "),_("li",[v._v("图的拓扑排序")]),v._v(" "),_("li",[v._v("最短路问题求解（dijkstra 算法等）")])]),v._v(" "),_("h2",{attrs:{id:"优点和缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优点和缺点"}},[v._v("#")]),v._v(" 优点和缺点")]),v._v(" "),_("p",[v._v("优点：")]),v._v(" "),_("ul",[_("li",[v._v("接近人的思维，易于理解")]),v._v(" "),_("li",[v._v("不会爆栈")]),v._v(" "),_("li",[v._v("求最短路")])]),v._v(" "),_("p",[v._v("缺点：")]),v._v(" "),_("ul",[_("li",[v._v("代码实现较长")])]),v._v(" "),_("h2",{attrs:{id:"题目"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#题目"}},[v._v("#")]),v._v(" 题目")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("102.二叉树的层序遍历")])]),v._v(" "),_("li",[_("strong",[v._v("107.二叉树的层次遍历 II")])]),v._v(" "),_("li",[_("strong",[v._v("199.二叉树的右视图")])]),v._v(" "),_("li",[_("strong",[v._v("637.二叉树的层平均值")])]),v._v(" "),_("li",[_("strong",[v._v("429.N 叉树的前序遍历")])]),v._v(" "),_("li",[_("strong",[v._v("515.在每个树行中找最大值")])]),v._v(" "),_("li",[_("strong",[v._v("116.填充每个节点的下一个右侧节点指针")])]),v._v(" "),_("li",[_("strong",[v._v("117.填充每个节点的下一个右侧节点指针 II")])]),v._v(" "),_("li",[_("strong",[v._v("104.二叉树的最大深度")])]),v._v(" "),_("li",[_("strong",[v._v("111.二叉树的最小深度")])])])])}),[],!1,null,null,null);_.default=r.exports}}]);