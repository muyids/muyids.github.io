(window.webpackJsonp=window.webpackJsonp||[]).push([[269],{544:function(v,_,i){"use strict";i.r(_);var e=i(14),l=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"思路"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#思路"}},[v._v("#")]),v._v(" 思路")]),v._v(" "),_("ul",[_("li",[v._v("索引是什么？")]),v._v(" "),_("li",[v._v("设计原则 和 优化？")]),v._v(" "),_("li",[v._v("索引失效")]),v._v(" "),_("li",[v._v("覆盖索引和回表？")]),v._v(" "),_("li",[v._v("最左匹配")]),v._v(" "),_("li",[v._v("索引下推？")]),v._v(" "),_("li",[v._v("聚簇索引和非聚簇索引？")]),v._v(" "),_("li",[v._v("。。。")])]),v._v(" "),_("h2",{attrs:{id:"索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引"}},[v._v("#")]),v._v(" 索引")]),v._v(" "),_("h3",{attrs:{id:"目的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#目的"}},[v._v("#")]),v._v(" 目的")]),v._v(" "),_("p",[v._v("有序的数据结构，提高查询效率")]),v._v(" "),_("h3",{attrs:{id:"数据结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[v._v("#")]),v._v(" 数据结构")]),v._v(" "),_("p",[v._v("有序的数据结构：二叉搜索树，红黑树（平衡二叉搜索树），B-树，B+树（多路平衡查找树）")]),v._v(" "),_("p",[v._v("为什么不是红黑树？ 层高太高，io 寻址次数多")]),v._v(" "),_("p",[v._v("B-树和 B+树比较？")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("非叶子结点不存储 data，只存冗余索引")])]),v._v(" "),_("li",[_("p",[v._v("叶子节点包含所有索引字段")])]),v._v(" "),_("li",[_("p",[v._v("叶子节点用指针连接，提高区间访问性能")])])]),v._v(" "),_("h2",{attrs:{id:"设计原则-和-优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计原则-和-优化"}},[v._v("#")]),v._v(" 设计原则 和 优化")]),v._v(" "),_("ul",[_("li",[v._v("搜索项：where 字句中的字段做索引")]),v._v(" "),_("li",[v._v("唯一项：过多重复的列作为索引性能不好，比如性别这种枚举字段")]),v._v(" "),_("li",[v._v("短：比如字符串，应指定前缀")]),v._v(" "),_("li",[v._v("最左原则：")]),v._v(" "),_("li",[v._v("不过度设计：")]),v._v(" "),_("li",[v._v("尽量用主键，主键尽可能选择较短的整型")]),v._v(" "),_("li",[v._v("索引列不参与计算")]),v._v(" "),_("li",[v._v("尽量扩展 而不是 新建； 比如表中已经有 a 的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可")]),v._v(" "),_("li",[v._v("like 查询，”%”不要放在前面")]),v._v(" "),_("li",[v._v("Where 条件数据类型不匹配也无法使用索引\n优化：")])]),v._v(" "),_("p",[v._v("确保遵守上述 设计原则 后，慢 sql 可以使用 explain 分析执行过程，主要查看 type，extra 字段，")]),v._v(" "),_("ul",[_("li",[v._v("type: 从最优到最差的排序：system > const > eq_ref > ref > range > index > all ；至少要是 range 以上\n"),_("ul",[_("li",[v._v("all：（full table scan）全表扫描无疑是最差，若是百万千万级数据量，全表扫描会非常慢。")]),v._v(" "),_("li",[v._v("index：（full index scan）全索引文件扫描比 all 好很多，毕竟从索引树中找数据，比从全表中找数据要快。")]),v._v(" "),_("li",[v._v("range：只检索给定范围的行，使用索引来匹配行。范围缩小了，当然比全表扫描和全索引文件扫描要快。sql 语句中一般会有 between，in，>，< 等查询。")]),v._v(" "),_("li",[v._v("ref：非唯一性索引扫描，本质上也是一种索引访问，返回所有匹配某个单独值的行。比如查询公司所有属于研发团队的同事，匹配的结果是多个并非唯一值。")]),v._v(" "),_("li",[v._v("eq_ref：唯一性索引扫描，对于每个索引键，表中有一条记录与之匹配。比如查询公司的 CEO，匹配的结果只可能是一条记录，")]),v._v(" "),_("li",[v._v("const：表示通过索引一次就可以找到，const 用于比较 primary key 或者 unique 索引。因为只匹配一行数据，所以很快，若将主键至于 where 列表中，MySQL 就能将该查询转换为一个常量。")]),v._v(" "),_("li",[v._v("system：表只有一条记录（等于系统表），这是 const 类型的特列，平时不会出现，了解即可")])])]),v._v(" "),_("li",[v._v("Extra: 若提示的是 Using filesort(使用内部排序)和 Using temporary(使用临时表)则表明该 sql 需要立即优化了。如果是 Using index 表示该查询使用了覆盖索引，说明该 sql 语句的性能很好。\n"),_("ul",[_("li",[v._v("Using filesort： 说明 MySQL 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL 中无法利用索引完成的排序操作称为“文件排序” 。出现这个就要立刻优化 sql。")]),v._v(" "),_("li",[v._v("Using temporary： 使用了临时表保存中间结果，MySQL 在对查询结果排序时使用临时表。常见于排序 order by 和 分组查询 group by。 出现这个更要立刻优化 sql。")]),v._v(" "),_("li",[v._v("Using index： 表示相应的 select 操作中使用了覆盖索引（Covering index），避免访问了表的数据行，效果不错！如果同时出现 Using where，表明索引被用来执行索引键值的查找。如果没有同时出现 Using where，表示索引用来读取数据而非执行查找动作。\n覆盖索引（Covering Index） ：也叫索引覆盖，就是 select 的数据列只用从索引中就能够取得，不必读取数据行，MySQL 可以利用索引返回 select 列表中的字段，而不必根据索引再次读取数据文件。")]),v._v(" "),_("li",[v._v("Using index condition： 在 5.6 版本后加入的新特性，优化器会在索引存在的情况下，通过符合 RANGE 范围的条数 和 总数的比例来选择是使用索引还是进行全表遍历。")]),v._v(" "),_("li",[v._v("Using where： 表明使用了 where 过滤")]),v._v(" "),_("li",[v._v("Using join buffer： 表明使用了连接缓存")]),v._v(" "),_("li",[v._v("impossible where： where 语句的值总是 false，不可用，不能用来获取任何元素")]),v._v(" "),_("li",[v._v("distinct： 优化 distinct 操作，在找到第一匹配的元组后即停止找同样值的动作。")])])])]),v._v(" "),_("h2",{attrs:{id:"索引失效"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引失效"}},[v._v("#")]),v._v(" 索引失效")]),v._v(" "),_("p",[v._v("索引失效的情况有很多，仅列举几种：")]),v._v(" "),_("ul",[_("li",[v._v("索引本身失效")]),v._v(" "),_("li",[v._v("大表，且 where 出来的数据太多")]),v._v(" "),_("li",[v._v("数据类型不对，隐式类型转换")]),v._v(" "),_("li",[v._v("索引列进行 运算")]),v._v(" "),_("li",[v._v("不满足最左匹配不走索引")]),v._v(" "),_("li",[v._v("。。。")])])])}),[],!1,null,null,null);_.default=l.exports}}]);