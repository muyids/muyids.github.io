(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{283:function(a,s,v){"use strict";v.r(s);var _=v(14),t=Object(_.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("p",[s("code",[a._v("一致性哈希")]),a._v("常用来解决"),s("code",[a._v("单点的不稳定性问题")])]),a._v(" "),s("h2",{attrs:{id:"算法原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#算法原理"}},[a._v("#")]),a._v(" 算法原理")]),a._v(" "),s("p",[a._v("先构造一个长度为 232 的整数环（这个环被称为一致性 Hash 环），根据节点名称的 Hash 值（其分布为[0, 232-1]）将服务器节点放置在这个 Hash 环上，\n然后根据数据的 Key 值计算得到其 Hash 值（其分布也为[0, 232-1]），\n接着在 Hash 环上顺时针查找距离这个 Key 值的 Hash 值最近的服务器节点，完成 Key 到服务器的映射查找。")]),a._v(" "),s("p",[a._v("这种算法解决了普通余数 Hash 算法伸缩性差的问题，可以保证在上线、下线服务器的情况下尽量有多的请求命中原来路由到的服务器。")]),a._v(" "),s("p",[a._v("一致性 Hash 算法比普通的余数 Hash 算法更具有伸缩性，但是同时其算法实现也更为复杂。")]),a._v(" "),s("h2",{attrs:{id:"数据结构的选取"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据结构的选取"}},[a._v("#")]),a._v(" 数据结构的选取")]),a._v(" "),s("p",[a._v("一致性 Hash 算法最先要考虑的一个问题是：构造出一个长度为 232 的整数环，根据节点名称的 Hash 值将服务器节点放置在这个 Hash 环上。")]),a._v(" "),s("p",[a._v("那么，整数环应该使用何种数据结构，才能使得运行时的时间复杂度最低？")]),a._v(" "),s("p",[a._v("首先说明一点，关于时间复杂度，常见的时间复杂度与时间效率的关系有如下的经验规则：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("O(1) < O(log2N) < O(n) < O(N * log2N) < O(N2) < O(N3) < 2N < 3N < N!\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("一般来说，前四个效率比较高，中间两个差强人意，后三个比较差（只要 N 比较大，这个算法就动不了了）。\nOK，继续前面的话题，应该如何选取数据结构，我认为有以下几种可行的解决方案。")]),a._v(" "),s("h3",{attrs:{id:"解决方案一-排序-list"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决方案一-排序-list"}},[a._v("#")]),a._v(" 解决方案一：排序+List")]),a._v(" "),s("p",[a._v("我想到的第一种思路是：算出所有待加入数据结构的节点名称的 Hash 值放入一个数组中，然后使用某种排序算法将其从小到大进行排序，\n最后将排序后的数据放入 List 中，采用 List 而不是数组是为了结点的扩展考虑。\n之后，待路由的结点，只需要在 List 中找到第一个 Hash 值比它大的服务器节点就可以了，\n比如服务器节点的 Hash 值是"),s("code",[a._v("[0,2,4,6,8,10]")]),a._v("，带路由的结点是 7，只需要找到第一个比 7 大的整数，也就是 8，就是我们最终需要路由过去的服务器节点。\n如果暂时不考虑前面的排序，那么这种解决方案的时间复杂度：")]),a._v(" "),s("p",[a._v("（1）最好的情况是第一次就找到，时间复杂度为 O(1)")]),a._v(" "),s("p",[a._v("（2）最坏的情况是最后一次才找到，时间复杂度为 O(N)")]),a._v(" "),s("p",[a._v("平均下来时间复杂度为 O(0.5N+0.5)，忽略首项系数和常数，时间复杂度为 O(N)。")]),a._v(" "),s("p",[a._v("但是如果考虑到之前排序算法的时间复杂度：")]),a._v(" "),s("p",[s("img",{attrs:{src:"/image/sort-o.png",alt:"各种常用排序算法"}})]),a._v(" "),s("p",[a._v("看得出来，排序算法要么稳定但是时间复杂度高、要么时间复杂度低但不稳定，最好的时间复杂度仍然有 O(N*logN)")]),a._v(" "),s("h3",{attrs:{id:"解决方案二-遍历-list"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决方案二-遍历-list"}},[a._v("#")]),a._v(" 解决方案二：遍历+List")]),a._v(" "),s("p",[a._v("既然排序操作比较耗性能，那么能不能不排序？可以的，所以进一步的，有了第二种解决方案。")]),a._v(" "),s("p",[a._v("解决方案使用 List 不变，不过可以采用遍历的方式：")]),a._v(" "),s("p",[a._v("（1）服务器节点不排序，其 Hash 值全部直接放入一个 List 中")]),a._v(" "),s("p",[a._v("（2）带路由的节点，算出其 Hash 值，由于指明了”顺时针”，因此遍历 List，比待路由的节点 Hash 值大的算出差值并记录，比待路由节点 Hash 值小的忽略")]),a._v(" "),s("p",[a._v("（3）算出所有的差值之后，最小的那个，就是最终需要路由过去的节点")]),a._v(" "),s("p",[a._v("在这个算法中，看一下时间复杂度：")]),a._v(" "),s("p",[a._v("1、最好情况是只有一个服务器节点的 Hash 值大于带路由结点的 Hash 值，其时间复杂度是 O(N)+O(1)=O(N+1)，忽略常数项，即 O(N)")]),a._v(" "),s("p",[a._v("2、最坏情况是所有服务器节点的 Hash 值都大于带路由结点的 Hash 值，其时间复杂度是 O(N)+O(N)=O(2N)，忽略首项系数，即 O(N)")]),a._v(" "),s("p",[a._v("所以，总的时间复杂度就是 O(N)。其实算法还能更改进一些：给一个位置变量 X，如果新的差值比原差值小，X 替换为新的位置，否则 X 不变。这样遍历就减少了一轮，不过经过改进后的算法时间复杂度仍为 O(N)。")]),a._v(" "),s("p",[a._v("总而言之，这个解决方案和解决方案一相比，总体来看，似乎更好了一些。")]),a._v(" "),s("h3",{attrs:{id:"解决方案三-二叉查找树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决方案三-二叉查找树"}},[a._v("#")]),a._v(" 解决方案三：二叉查找树")]),a._v(" "),s("p",[a._v("抛开 List 这种数据结构，另一种数据结构则是使用二叉查找树。")]),a._v(" "),s("p",[a._v("当然我们不能简单地使用二叉查找树，因为可能出现不平衡的情况。平衡二叉查找树有 AVL 树、红黑树等，这里使用红黑树，选用红黑树的原因有两点：")]),a._v(" "),s("p",[a._v("1、红黑树主要的作用是用于存储有序的数据，这其实和第一种解决方案的思路又不谋而合了，但是它的效率非常高")]),a._v(" "),s("p",[a._v("2、JDK 里面提供了红黑树的代码实现 TreeMap 和 TreeSet")]),a._v(" "),s("p",[a._v("另外，以 TreeMap 为例，TreeMap 本身提供了一个 tailMap(K fromKey)方法，支持从红黑树中查找比 fromKey 大的值的集合，但并不需要遍历整个数据结构。")]),a._v(" "),s("p",[a._v("使用红黑树，可以使得查找的时间复杂度降低为 O(logN)，比上面两种解决方案，效率大大提升。")]),a._v(" "),s("p",[a._v("红黑树的数据结构决定了任何一个大于 N 的最小数据，它都只需要几次至几十次查找就可以查到。")]),a._v(" "),s("p",[a._v("当然，明确一点，有利必有弊，根据我另外一次测试得到的结论是，为了维护红黑树，数据插入效率 TreeMap 在三种数据结构里面是最差的，且插入要慢上 5~10 倍。")]),a._v(" "),s("h2",{attrs:{id:"应用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用"}},[a._v("#")]),a._v(" 应用")]),a._v(" "),s("ul",[s("li",[a._v("数据分片")]),a._v(" "),s("li",[a._v("memcache")])])])}),[],!1,null,null,null);s.default=t.exports}}]);