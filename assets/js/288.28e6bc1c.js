(window.webpackJsonp=window.webpackJsonp||[]).push([[288],{562:function(t,a,v){"use strict";v.r(a);var _=v(14),s=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("数据库命令规范")]),t._v(" "),a("ul",[a("li",[t._v("所有数据库对象名称必须使用小写字母并用下划线分割")]),t._v(" "),a("li",[t._v("所有数据库对象名称禁止使用 mysql 保留关键字\n（如果表名中包含关键字查询时，需要将其用单引号括起来）")]),t._v(" "),a("li",[t._v("数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符")]),t._v(" "),a("li",[t._v("临时库表必须以 tmp"),a("em",[t._v("为前缀并以日期为后缀，备份表必须以 bak")]),t._v("为前缀并以日期(时间戳)为后缀")]),t._v(" "),a("li",[t._v("所有存储相同数据的列名和列类型必须一致\n（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）")])]),t._v(" "),a("h1",{attrs:{id:"数据库基本设计规范"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库基本设计规范"}},[t._v("#")]),t._v(" 数据库基本设计规范")]),t._v(" "),a("h2",{attrs:{id:"所有表必须使用-innodb-存储引擎"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#所有表必须使用-innodb-存储引擎"}},[t._v("#")]),t._v(" 所有表必须使用 Innodb 存储引擎")]),t._v(" "),a("p",[t._v("没有特殊要求（即 Innodb 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 Innodb 存储引擎（mysql5.5 之前默认使用 Myisam，5.6 以后默认的为 Innodb）Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好")]),t._v(" "),a("h2",{attrs:{id:"数据库和表的字符集统一使用-utf8"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库和表的字符集统一使用-utf8"}},[t._v("#")]),t._v(" 数据库和表的字符集统一使用 UTF8")]),t._v(" "),a("p",[t._v("兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效")]),t._v(" "),a("h2",{attrs:{id:"所有表和字段都需要添加注释"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#所有表和字段都需要添加注释"}},[t._v("#")]),t._v(" 所有表和字段都需要添加注释")]),t._v(" "),a("p",[t._v("使用 comment 从句添加表和列的备注 从一开始就进行数据字典的维护")]),t._v(" "),a("h2",{attrs:{id:"尽量控制单表数据量的大小-建议控制在-500-万以内"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#尽量控制单表数据量的大小-建议控制在-500-万以内"}},[t._v("#")]),t._v(" 尽量控制单表数据量的大小，建议控制在 500 万以内")]),t._v(" "),a("p",[t._v("500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题\n可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小")]),t._v(" "),a("h2",{attrs:{id:"谨慎使用-mysql-分区表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#谨慎使用-mysql-分区表"}},[t._v("#")]),t._v(" 谨慎使用 MySQL 分区表")]),t._v(" "),a("p",[t._v("分区表在物理上表现为多个文件，在逻辑上表现为一个表\n谨慎选择分区键，跨分区查询效率可能更低\n建议采用物理分表的方式管理大数据")]),t._v(" "),a("h2",{attrs:{id:"尽量做到冷热数据分离-减小表的宽度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#尽量做到冷热数据分离-减小表的宽度"}},[t._v("#")]),t._v(" 尽量做到冷热数据分离，减小表的宽度")]),t._v(" "),a("p",[t._v("MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节 减少磁盘 IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的 IO） 更有效的利用缓存，避免读入无用的冷数据 经常一起使用的列放到一个表中（避免更多的关联操作）")]),t._v(" "),a("h2",{attrs:{id:"禁止在表中建立预留字段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#禁止在表中建立预留字段"}},[t._v("#")]),t._v(" 禁止在表中建立预留字段")]),t._v(" "),a("p",[t._v("预留字段的命名很难做到见名识义\n预留字段无法确认存储的数据类型，所以无法选择合适的类型\n对预留字段类型的修改，会对表进行锁定")]),t._v(" "),a("h2",{attrs:{id:"禁止在数据库中存储图片-文件等大的二进制数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#禁止在数据库中存储图片-文件等大的二进制数据"}},[t._v("#")]),t._v(" 禁止在数据库中存储图片，文件等大的二进制数据")]),t._v(" "),a("p",[t._v("通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机 IO 操作，文件很大时，IO 操作很耗时 通常存储于文件服务器，数据库只存储文件地址信息")]),t._v(" "),a("h2",{attrs:{id:"禁止在线上做数据库压力测试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#禁止在线上做数据库压力测试"}},[t._v("#")]),t._v(" 禁止在线上做数据库压力测试")]),t._v(" "),a("h2",{attrs:{id:"禁止从开发环境-测试环境直接连接生成环境数据库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#禁止从开发环境-测试环境直接连接生成环境数据库"}},[t._v("#")]),t._v(" 禁止从开发环境，测试环境直接连接生成环境数据库")]),t._v(" "),a("h1",{attrs:{id:"数据库字段设计规范"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库字段设计规范"}},[t._v("#")]),t._v(" 数据库字段设计规范")]),t._v(" "),a("h2",{attrs:{id:"优先选择符合存储需要的最小的数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优先选择符合存储需要的最小的数据类型"}},[t._v("#")]),t._v(" 优先选择符合存储需要的最小的数据类型")]),t._v(" "),a("h3",{attrs:{id:"原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原因"}},[t._v("#")]),t._v(" 原因")]),t._v(" "),a("p",[t._v("列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少\n在遍历时所需要的 IO 次数也就越多， 索引的性能也就越差")]),t._v(" "),a("h3",{attrs:{id:"方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法"}},[t._v("#")]),t._v(" 方法")]),t._v(" "),a("ul",[a("li",[t._v("将字符串转换成数字类型存储，如：将 IP 地址转换成整形数据。")]),t._v(" "),a("li",[t._v("对于非负型的数据（如自增 ID、整型 IP）来说，要优先使用无符号整型来存储")])]),t._v(" "),a("h2",{attrs:{id:"避免使用-text、blob-数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#避免使用-text、blob-数据类型"}},[t._v("#")]),t._v(" 避免使用 TEXT、BLOB 数据类型")]),t._v(" "),a("p",[t._v("最常见的 TEXT 类型可以存储 64k 的数据")]),t._v(" "),a("ul",[a("li",[t._v("建议把 BLOB 或是 TEXT 列分离到单独的扩展表中")]),t._v(" "),a("li",[t._v("TEXT 或 BLOB 类型只能使用前缀索引")])]),t._v(" "),a("h2",{attrs:{id:"避免使用-enum-类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#避免使用-enum-类型"}},[t._v("#")]),t._v(" 避免使用 ENUM 类型")]),t._v(" "),a("ul",[a("li",[t._v("修改 ENUM 值需要使用 ALTER 语句")]),t._v(" "),a("li",[t._v("ENUM 类型的 ORDER BY 操作效率低，需要额外操作")]),t._v(" "),a("li",[t._v("禁止使用数值作为 ENUM 的枚举值")])]),t._v(" "),a("h2",{attrs:{id:"尽可能把所有列定义为-not-null"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#尽可能把所有列定义为-not-null"}},[t._v("#")]),t._v(" 尽可能把所有列定义为 NOT NULL")]),t._v(" "),a("p",[t._v("原因：")]),t._v(" "),a("ul",[a("li",[t._v("索引 NULL 列需要额外的空间来保存，所以要占用更多的空间；")]),t._v(" "),a("li",[t._v("进行比较和计算时要对 NULL 值做特别的处理")])]),t._v(" "),a("h2",{attrs:{id:"使用-timestamp-4-个字节-或-datetime-类型-8-个字节-存储时间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-timestamp-4-个字节-或-datetime-类型-8-个字节-存储时间"}},[t._v("#")]),t._v(" 使用 TIMESTAMP（4 个字节）或 DATETIME 类型（8 个字节）存储时间")]),t._v(" "),a("p",[t._v("TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07。TIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储。\n经常会有人用字符串存储日期型的数据**（不正确的做法）**")]),t._v(" "),a("ul",[a("li",[t._v("缺点 1：无法用日期函数进行计算和比较")]),t._v(" "),a("li",[t._v("缺点 2：用字符串存储日期要占用更多的空间")])]),t._v(" "),a("h2",{attrs:{id:"同财务相关的金额类数据必须使用-decimal-类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同财务相关的金额类数据必须使用-decimal-类型"}},[t._v("#")]),t._v(" 同财务相关的金额类数据必须使用 decimal 类型")]),t._v(" "),a("ul",[a("li",[t._v("非精准浮点：float,double")]),t._v(" "),a("li",[t._v("精准浮点：decimal\nDecimal 类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。可用于存储比 bigint 更大的整型数据。")])]),t._v(" "),a("h2",{attrs:{id:"什么是-sql-注入-sql-injection"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-sql-注入-sql-injection"}},[t._v("#")]),t._v(" 什么是 SQL 注入（SQL Injection）")]),t._v(" "),a("p",[t._v("所谓 SQL 注入式攻击，就是攻击者把 SQL 命令插入到 Web 表单的输入域或页面请求的查询字符串，欺骗服务器执行恶意的 SQL 命令。")]),t._v(" "),a("p",[t._v("在某些表单中，用户输入的内容直接用来构造（或者影响）动态 SQL 命令，或作为存储过程的输入参数，这类表单特别容易受到 SQL 注入式攻击。")]),t._v(" "),a("h2",{attrs:{id:"分库分表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分库分表"}},[t._v("#")]),t._v(" 分库分表")]),t._v(" "),a("p",[t._v("当 mysql 数据库单表数据量破千万以后，MySQL 性能将下降厉害，并且随着业务的规模化，单表将很难抗住并发压力，出现故障后恢复时间变长对业务影响也会变大，因此需要考虑数据水平扩展。")]),t._v(" "),a("p",[t._v("想水平扩展，就需要分库分表的支持，分库分表这四个字说起来很容易，按照 id 取模将数据打散分摊压力，但是干完这些之后需要解决由此带来的问题，这些很难：")]),t._v(" "),a("ol",[a("li",[t._v("事务支持，扩库/扩表后事务就成分布式的了，问题难度显然上升了一个级别")]),t._v(" "),a("li",[t._v("查询结果合并，这个看起来不难，但是把 order by/limit/查询中不带分表字段等加上，要解决的问题还也不少")]),t._v(" "),a("li",[t._v("join，这个更难")]),t._v(" "),a("li",[t._v("分库？分表？还是分库分表？这个需要考虑并做一个决定")]),t._v(" "),a("li",[t._v("分完后能否合并？分容易，合很难")]),t._v(" "),a("li",[t._v("。。。")])])])}),[],!1,null,null,null);a.default=s.exports}}]);