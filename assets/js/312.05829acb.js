(window.webpackJsonp=window.webpackJsonp||[]).push([[312],{586:function(v,_,s){"use strict";s.r(_);var a=s(14),e=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"redis-持久化和主从复制原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-持久化和主从复制原理"}},[v._v("#")]),v._v(" Redis 持久化和主从复制原理")]),v._v(" "),_("p",[v._v("3 种持久化方式： RDB、AOF、混合持久化")]),v._v(" "),_("h3",{attrs:{id:"rdb"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rdb"}},[v._v("#")]),v._v(" RDB")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("Redis 将内存数据库快照保存在名字为 dump.rdb 的二进制文件")])]),v._v(" "),_("li",[_("p",[v._v("快照生成规则")]),v._v(" "),_("ul",[_("li",[v._v("N 秒内数据集至少有 M 个改动 （设置 "),_("code",[v._v("save 60 1000")]),v._v(' 会让 Redis 在满足" 60 秒内有至少有 1000 个键被改动 " ）')]),v._v(" "),_("li",[v._v("手动执行命令生成：客户端执行命令 save 或 bgsave 可以生成 dump.rdb 文件 - save 是同步命令，bgsave 是异步命令 - Redis 默认是使用的 bgsave\n优点：")])])]),v._v(" "),_("li",[_("p",[v._v("可以恢复到之前某一时间点的数据")])]),v._v(" "),_("li",[_("p",[v._v("恢复速度快\n缺点：")])]),v._v(" "),_("li",[_("p",[v._v("数据丢失多")])]),v._v(" "),_("li",[_("p",[v._v("save 保存快照，如果文件很大，阻塞时间长")])])]),v._v(" "),_("h3",{attrs:{id:"aof"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#aof"}},[v._v("#")]),v._v(" AOF")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("通过修改配置文件来打开 AOF 功能："),_("code",[v._v("appendonly yes")])])]),v._v(" "),_("li",[_("p",[v._v("将修改的每一条指令记录进文件 appendonly.aof 中")])]),v._v(" "),_("li",[_("p",[v._v("配置 fsync 规则（三个选项）")]),v._v(" "),_("ul",[_("li",[v._v("appendfsync always：每次有新命令追加到 AOF 文件时就执行一次 fsync ，非常慢，也非常安全")]),v._v(" "),_("li",[v._v("appendfsync everysec：每秒 fsync 一次，在故障时只会丢失 1 秒钟的数据。")]),v._v(" "),_("li",[v._v("appendfsync no：redis 不会主动调用 fsync 去将 AOF 日志内容同步到磁盘， 完全依赖于操作系统来处理。更快，也更不安全的选择")])]),v._v(" "),_("p",[v._v("推荐（并且也是默认）的措施为每秒 fsync 一次， 这种 fsync 策略可以兼顾速度和安全性。")])])]),v._v(" "),_("p",[v._v("优点：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("写入性能好，文件也不容易破损。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("适合做灾难性数据误删除的紧急恢复")]),v._v("；AOF 的日志是通过一个叫非常可读的方式记录的，这样的特性就适合做灾难性数据误删除的紧急恢复了，比如公司的实习生通过 flushall 清空了所有的数据，只要这个时候 "),_("strong",[v._v("后台重写还没发生")]),v._v("，你马上拷贝一份 AOF 日志文件，把最后一条 flushall 命令删了就完事了。\n缺点：")])]),v._v(" "),_("li",[_("p",[v._v("文件大")])])]),v._v(" "),_("h3",{attrs:{id:"混合持久化-加强版的-aof"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#混合持久化-加强版的-aof"}},[v._v("#")]),v._v(" 混合持久化（加强版的 AOF）")]),v._v(" "),_("ul",[_("li",[v._v("重启 Redis 时，很少使用 RDB 来恢复数据，因为会丢失大量数据")]),v._v(" "),_("li",[v._v("通常使用 AOF 日志重放，但是重放 AOF 日志性能较差，为了解决这个问题，redis 引入了混合持久化")]),v._v(" "),_("li",[v._v("开启混合持久化 "),_("code",[v._v("aof-use-rdb-preamble yes")])]),v._v(" "),_("li",[v._v("开启了混合持久化，AOF 在重写时，不再是单纯将内存数据转换为 RESP 命令写入 AOF 文件")]),v._v(" "),_("li",[v._v("而是将重写这一刻之前的内存做 RDB 快照处理，并且将 RDB 快照内容和增量的 AOF 修改内存数据的命令存在一起，写入新的 AOF 文件")]),v._v(" "),_("li",[v._v("新的 "),_("code",[v._v("appendonly.aof")]),v._v(" 文件 由 "),_("strong",[v._v("RDB 快照 + 增量的 AOF 修改")]),v._v(" 组成")])])])}),[],!1,null,null,null);_.default=e.exports}}]);