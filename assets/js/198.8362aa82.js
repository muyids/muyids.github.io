(window.webpackJsonp=window.webpackJsonp||[]).push([[198],{472:function(_,v,o){"use strict";o.r(v);var t=o(14),e=Object(t.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("p",[_._v("大纲：")]),_._v(" "),v("ul",[v("li",[_._v("消费者分区分配策略")]),_._v(" "),v("li",[_._v("rebalance 机制")]),_._v(" "),v("li",[_._v("offset 的维护")])]),_._v(" "),v("hr"),_._v(" "),v("h4",{attrs:{id:"消费者分区分配策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#消费者分区分配策略"}},[_._v("#")]),_._v(" "),v("strong",[_._v("消费者分区分配策略")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("RoundRobin 轮询分区")])]),_._v(" "),v("li",[v("p",[_._v("Range 范围分区（默认)")])]),_._v(" "),v("li",[v("p",[_._v("Sticky 策略（推荐）")])])]),_._v(" "),v("p",[_._v("一个 partition 只能由一个 consumer 消费")]),_._v(" "),v("p",[_._v("由于 一个 "),v("code",[_._v("consumer group")]),_._v("中有多个"),v("code",[_._v("consumer")]),_._v("，一个"),v("code",[_._v("topic")]),_._v("有多个"),v("code",[_._v("partition")]),_._v("，需要进行"),v("code",[_._v("partition")]),_._v("的分配，确定每个"),v("code",[_._v("partition")]),_._v("由哪个"),v("code",[_._v("consumer")]),_._v("来消费")]),_._v(" "),v("p",[v("strong",[_._v("1、RoundRobin 轮询分区")])]),_._v(" "),v("p",[_._v("使用 RoundRobin 轮询分区策略，必须满足如下两个条件：")]),_._v(" "),v("ol",[v("li",[_._v("每个消费者订阅的主题，必须是相同的")]),_._v(" "),v("li",[_._v("每个主题的消费者实例都是相同的\n"),v("strong",[_._v("2、Range 范围分区（默认）")])])]),_._v(" "),v("p",[_._v("Range 范围分区策略是对每个 topic 而言的。首先对同一个 topic 里面的分区按照序号进行排序，并对消费者按照字母顺序进行排序。假如现在有 10 个分区，3 个消费者，排序后的分区将会是 0,1,2,3,4,5,6,7,8,9；消费者排序完之后将会是 C1-0,C2-0,C3-0。通过 partitions 数/consumer 数   来决定每个消费者应该消费几个分区。如果除不尽，那么前面几个消费者将会多消费 1 个分区。")]),_._v(" "),v("p",[_._v("Range 范围分区的弊端：")]),_._v(" "),v("p",[_._v("如上，只是针对 1 个 topic 而言，C1-0 消费者多消费 1 个分区影响不是很大。如果有 N 多个 topic，那么针对每个 topic，消费者 C1-0 都将多消费 1 个分区，topic 越多，C1-0 消费的分区会比其他消费者明显多消费 N 个分区。这就是 Range 范围分区的一个很明显的弊端了")]),_._v(" "),v("p",[v("strong",[_._v("3、Sticky 策略(after 0.11)")])]),_._v(" "),v("p",[_._v("粘性策略")]),_._v(" "),v("p",[_._v("解决应用宕机或重启的时候，上述两种方式会重复消费")]),_._v(" "),v("p",[_._v("基于 RoundRobin 做初始化分发")]),_._v(" "),v("hr"),_._v(" "),v("h4",{attrs:{id:"rebalance-机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#rebalance-机制"}},[_._v("#")]),_._v(" rebalance 机制")]),_._v(" "),v("p",[v("strong",[_._v("触发条件")])]),_._v(" "),v("p",[_._v("当出现以下几种情况时，Kafka 会进行一次分区分配操作，即 Kafka 消费者端的 Rebalance 操作")]),_._v(" "),v("ul",[v("li",[_._v("消费者组组员个数变化；")]),_._v(" "),v("li",[_._v("topic 个数发生变化")]),_._v(" "),v("li",[_._v("topic 分区数发生变化")])]),_._v(" "),v("p",[v("strong",[_._v("coordinator 协调过程")])]),_._v(" "),v("ul",[v("li",[_._v("消费者如何发现协调者")]),_._v(" "),v("li",[_._v("消费者如何确定分配策略")]),_._v(" "),v("li",[_._v("如果需要再均衡分配策略的影响")])]),_._v(" "),v("hr"),_._v(" "),v("h4",{attrs:{id:"offset-的维护"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#offset-的维护"}},[_._v("#")]),_._v(" offset 的维护")]),_._v(" "),v("p",[_._v("由于 consumer 在消费过程中可能会出现断电宕机等故障，consumer 恢复后，需要从故障前的位置的继续消费，所以 consumer 需要实时记录自己消费到了哪个 offset，以便故障恢复后继续消费。")]),_._v(" "),v("ul",[v("li",[_._v("0.9 版本之前, consumer 默认将 offset 保存在 zookeeper 中；")]),_._v(" "),v("li",[_._v("0.9 版本以后，默认将 offset 保存在 kafka 的内置 topic 中，该 topic 为"),v("code",[_._v("__consumer_offsets")])])])])}),[],!1,null,null,null);v.default=e.exports}}]);