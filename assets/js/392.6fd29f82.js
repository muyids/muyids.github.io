(window.webpackJsonp=window.webpackJsonp||[]).push([[392],{666:function(t,a,r){"use strict";r.r(a);var v=r(14),o=Object(v.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h4",{attrs:{id:"一、hashmap-实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、hashmap-实现原理"}},[t._v("#")]),t._v(" 一、hashmap 实现原理")]),t._v(" "),a("h4",{attrs:{id:"二、线程安全的-hashmap-是-concurrenthashmap-的实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、线程安全的-hashmap-是-concurrenthashmap-的实现原理"}},[t._v("#")]),t._v(" 二、线程安全的 HashMap 是？ConcurrentHashMap 的实现原理？")]),t._v(" "),a("p",[a("strong",[t._v("分段锁+cas")])]),t._v(" "),a("p",[t._v("ConcurrentHashMap 是 java.util.concurrent 包（JDK 1.5 时引入）中的一个类，它提供了线程安全的 HashMap 实现。")]),t._v(" "),a("p",[t._v("在 JDK1.7 及其之前 ConcurrentHashMap 实现线程安全的方法相对比较简单：")]),t._v(" "),a("ul",[a("li",[t._v("其内部将数据分为数个“"),a("strong",[t._v("段（Segment）")]),t._v("”，其数量和并发级别有关系，具体是“大于等于并发级别的最小的 2 的幂次”。")]),t._v(" "),a("li",[t._v("每个 segment 使用单独的 ReentrantLock（分段锁）。")]),t._v(" "),a("li",[t._v("如果操作涉及不同 segment，则可以并发执行，如果是同一个 segment 则会进行锁的竞争和等待。")]),t._v(" "),a("li",[t._v("此设计的效率是高于 synchronized 的。\n不过 JDK8 之后，ConcurrentHashMap 舍弃了 ReentrantLock，而重新使用了 synchronized。其原因大致有一下几点：")])]),t._v(" "),a("ol",[a("li",[t._v("加入多个分段锁浪费内存空间。")]),t._v(" "),a("li",[t._v("生产环境中， map 在放入时竞争同一个锁的概率非常小，分段锁反而会造成更新等操作的长时间等待。")]),t._v(" "),a("li",[t._v("为了提高 GC 的效率")])]),t._v(" "),a("p",[t._v("新的 ConcurrentHashMap 中使用 synchronized 关键字+CAS 操作保证了线程安全。其实现细节详见"),a("a",{attrs:{href:"https://link.zhihu.com/?target=https%3A//my.oschina.net/pingpangkuangmo/blog/817973%23h2_12",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://my.oschina.net/pingpangkuangmo/blog/817973#h2_12"),a("OutboundLink")],1),t._v("。这里不再赘述。")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("这里简单介绍一下什么是"),a("strong",[t._v("CAS")]),t._v("。")]),t._v(" "),a("p",[t._v("CAS 全称 Compare and Swap，即比较并替换。Doug lea 大神在 ConcurrentHashMap 的各项操作中便大量使用了 CAS 技术。")]),t._v(" "),a("p",[t._v("CAS 本质上很简单，一般至少有 3 个参数：一个变量 v，旧值 A，新值 B。当且仅当变量 v 当前的值和旧值 A 相同时，才会将 v 的值更新为 B。这整个操作是原子化的，不同平台的 JVM 也有不同的实现，一般以 Native 方法执行。")]),t._v(" "),a("h4",{attrs:{id:"三、volatile-的底层原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、volatile-的底层原理"}},[t._v("#")]),t._v(" 三、volatile 的底层原理")]),t._v(" "),a("p",[t._v("可见性")]),t._v(" "),a("p",[t._v("有序性")]),t._v(" "),a("h4",{attrs:{id:"四、synchronized"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、synchronized"}},[t._v("#")]),t._v(" 四、synchronized")]),t._v(" "),a("p",[t._v("他就是用来解决"),a("strong",[t._v("多个线程间相同资源访问的同步性问题")]),t._v("的；说白了就是保证"),a("strong",[t._v("线程安全")]),t._v("的。")]),t._v(" "),a("p",[t._v("那他是怎么保证的呢？他通过修饰方法或代码块，使其在同一时间，只能被一个线程访问。")]),t._v(" "),a("p",[t._v("四种使用方式：")]),t._v(" "),a("ol",[a("li",[t._v("修饰普通同步方法 ：synchronized void lock(){ } 锁的是对象")]),t._v(" "),a("li",[t._v("修饰静态同步方法：synchronized static void lock(){} 修饰静态方法锁定的是这个类的所有对象")]),t._v(" "),a("li",[t._v("修饰一个对象（也叫修饰一个代码块）：void lock(){ synchronized (this){ } } ；锁的是对象")]),t._v(" "),a("li",[t._v("修饰一个类：void lock(){ synchronized (obj.class){ } } 所有对象共用一把锁\n底层原理：")])]),t._v(" "),a("p",[t._v("synchronized 是通过持有和释放 monitor 对象实现的")]),t._v(" "),a("p",[t._v("<同步代码块>通过 monitorenter 和 monitorexit 指令实现；当我们用 synchronized 去修饰代码块，编译的时候就会在代码块开头和结尾插入 monitorenter 和 monitorexit 指令（编译后的指令码我们可以通过"),a("code",[t._v("javap -c xx.class")]),t._v("查看）；执行 monitorenter 的时候，尝试获取对象的锁，如果锁的计数器为 0，获取 monitor 成功，计数器+1，执行 monitorexit，则-1 释放")]),t._v(" "),a("p",[t._v("<同步代码块>")]),t._v(" "),a("h4",{attrs:{id:"五、锁升级的过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、锁升级的过程"}},[t._v("#")]),t._v(" 五、锁升级的过程")]),t._v(" "),a("p",[t._v("升级过程：无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁")]),t._v(" "),a("h4",{attrs:{id:"六、线程池的参数和工作原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六、线程池的参数和工作原理"}},[t._v("#")]),t._v(" 六、线程池的参数和工作原理")]),t._v(" "),a("p",[t._v("七大参数：")]),t._v(" "),a("p",[t._v("工作原理：")]),t._v(" "),a("p",[t._v("拒绝策略有哪些：")]),t._v(" "),a("ul",[a("li",[t._v("ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出 RejectedExecutionException 异常。")]),t._v(" "),a("li",[t._v("ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。")]),t._v(" "),a("li",[t._v("ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务")]),t._v(" "),a("li",[t._v("ThreadPoolExecutor.CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务")])]),t._v(" "),a("h4",{attrs:{id:"七、垃圾回收算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#七、垃圾回收算法"}},[t._v("#")]),t._v(" 七、垃圾回收算法")]),t._v(" "),a("h4",{attrs:{id:"八、cms"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#八、cms"}},[t._v("#")]),t._v(" 八、CMS")]),t._v(" "),a("p",[a("strong",[t._v("遇到特别多垃圾碎片会怎么处理")])]),t._v(" "),a("h4",{attrs:{id:"九、jvm-oom-的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#九、jvm-oom-的问题"}},[t._v("#")]),t._v(" 九、jvm OOM 的问题")]),t._v(" "),a("p",[t._v("jdk 的命令和 arthas 去")])])}),[],!1,null,null,null);a.default=o.exports}}]);