(window.webpackJsonp=window.webpackJsonp||[]).push([[311],{585:function(v,_,s){"use strict";s.r(_);var e=s(14),t=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"高可用方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#高可用方案"}},[v._v("#")]),v._v(" 高可用方案")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("主从")])]),v._v(" "),_("li",[_("p",[v._v("哨兵")]),v._v(" "),_("ul",[_("li",[v._v("着眼于高可用，在 master 宕机时会自动将 slave 提升为 master，继续提供服务")])])]),v._v(" "),_("li",[_("p",[v._v("集群")]),v._v(" "),_("ul",[_("li",[v._v("着眼于扩展性，在单个 Redis 内存不足时，使用 Cluster 进行分片存储")])])])]),v._v(" "),_("h2",{attrs:{id:"主从"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#主从"}},[v._v("#")]),v._v(" 主从")]),v._v(" "),_("p",[v._v("主从同步: 数据可以从主服务器向任意数量的从服务器上同步，使用的是"),_("strong",[v._v("发布/订阅机制")])]),v._v(" "),_("h3",{attrs:{id:"配置步骤"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#配置步骤"}},[v._v("#")]),v._v(" 配置步骤")]),v._v(" "),_("ol",[_("li",[v._v("当配置好 slave 后，slave 与 master 建立连接，然后 slave 发送 sync 命令")]),v._v(" "),_("li",[v._v("master 都会启动一个后台进程，将 数据库快照保存到文件中（RDB），同时 master 主进程会开始收集新的写命令并缓存（AOF）")]),v._v(" "),_("li",[v._v("后台进程完成写文件后，master 就发送文件给 slave，slave 将 文件保存到硬盘上，再加载到内存中，接着 master 就会把缓存的命令转发给 slave，后续 master 将收到的写命令发送给 slave。")]),v._v(" "),_("li",[v._v("可以是 1 Master 多 Slave，可以分层，Slave 下可以再接 Slave，可扩展成树状结构。")])]),v._v(" "),_("h3",{attrs:{id:"应用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#应用"}},[v._v("#")]),v._v(" 应用")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("热备份")])]),v._v(" "),_("li",[_("p",[v._v("读写分离")])])]),v._v(" "),_("h3",{attrs:{id:"问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[v._v("#")]),v._v(" 问题")]),v._v(" "),_("ul",[_("li",[v._v("无法保证高可用")]),v._v(" "),_("li",[v._v("没有解决 master 写的压力")])]),v._v(" "),_("h2",{attrs:{id:"哨兵"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#哨兵"}},[v._v("#")]),v._v(" 哨兵")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://muyids.oss-cn-beijing.aliyuncs.com/46b9dee366d2430299afc2bfdfe5d9ff~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}})]),v._v(" "),_("ul",[_("li",[v._v("特殊的 Redis 服务："),_("strong",[v._v("不提供读写服务")]),v._v("，主要"),_("strong",[v._v("用来监控 Redis 实例节点")]),v._v("。")]),v._v(" "),_("li",[v._v("哨兵作用\n"),_("ul",[_("li",[v._v("监控: Sentinel 会不断地通过发送命令，检查你的主服务器和从服务器是否运作正常")]),v._v(" "),_("li",[v._v("自动故障迁移（Automatic failover）: 主从切换；当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作")])])]),v._v(" "),_("li",[v._v("多哨兵模式: 我们可以设置多个哨兵(一般三台)，哨兵之间也可以互相监控状态，保证 Redis 集群高可用")])]),v._v(" "),_("p",[v._v("优点：")]),v._v(" "),_("ul",[_("li",[v._v("保证高可用")]),v._v(" "),_("li",[v._v("监控各个节点")]),v._v(" "),_("li",[v._v("自动故障迁移")])]),v._v(" "),_("p",[v._v("缺点：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("主从模式，切换需要时间，丢数据")])]),v._v(" "),_("li",[_("p",[v._v("没有解决 master 写的压力")])])]),v._v(" "),_("p",[v._v("自动故障迁移（Automatic failover）过程：主观下线->投票，客观下线->failover 操作")]),v._v(" "),_("ul",[_("li",[v._v("假设主服务器宕机，哨兵 1 先检测到这个结果，系统并不会马上进行"),_("code",[v._v("failover过程")]),v._v("，仅仅是哨兵 1 主观的认为主服务器不可用，这个现象称为"),_("code",[v._v("主观下线")]),v._v("。")]),v._v(" "),_("li",[v._v("当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行"),_("code",[v._v("failover操作")]),v._v("。")]),v._v(" "),_("li",[v._v("切换成功后，就会通过发布订阅模式通知其他从服务器，这个过程称为"),_("code",[v._v("客观下线")]),v._v("。")])]),v._v(" "),_("h2",{attrs:{id:"集群"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#集群"}},[v._v("#")]),v._v(" 集群")]),v._v(" "),_("p",[v._v("redis 集群模式的工作原理能说一下么？在集群模式下，redis 的 key 是如何寻址的？分布式寻址都有哪些算法？了 解一致性 hash 算法吗？")]),v._v(" "),_("p",[v._v("工作机制：")]),v._v(" "),_("ul",[_("li",[v._v("在 Redis 的每个节点上，都有一个插槽（slot），取值范围为"),_("code",[v._v("0-16383")])]),v._v(" "),_("li",[v._v("当我们存取 key 的时候，Redis 会根据"),_("code",[v._v("CRC16")]),v._v("的算法得出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在"),_("code",[v._v("0-16383")]),v._v("之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作")]),v._v(" "),_("li",[v._v("为了保证高可用，Cluster 模式也引入主从复制模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点")]),v._v(" "),_("li",[v._v("当其它主节点 ping 一个主节点 A 时，如果半数以上的主节点与 A 通信超时，那么认为主节点 A 宕机了。如果主节点 A 和它的从节点都宕机了，那么该集群就无法再提供服务了\nCluster 模式集群节点最小配置 6 个节点(3 主 3 从)，其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。")])]),v._v(" "),_("p",[v._v("特点：")]),v._v(" "),_("ul",[_("li",[v._v("数据自动分片，每个 master 放一部分数据")]),v._v(" "),_("li",[v._v("支持多个 master 并都可以挂载多个 slave")]),v._v(" "),_("li",[v._v("cluster bus 提供节点通信")])]),v._v(" "),_("p",[v._v("redis cluster，主要是针对"),_("code",[v._v("海量数据+高并发+高可用")]),v._v("的场景。redis cluster 支撑 N 个 redis master node，每个 master node 都可以挂载多个 slave node。这样整个 redis 就可以横向扩容了。如果你要支撑更大数据量的缓存，那就横向扩容更多的 master 节点，每个 master 节点就能存放更多的数据了。")]),v._v(" "),_("p",[v._v("在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是 加 1w 的端口号 16379。16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，gossip 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。")]),v._v(" "),_("p",[v._v("内部通信机制：")]),v._v(" "),_("p",[v._v("集群元数据的维护有两种方式：集中式、Gossip 协议")]),v._v(" "),_("p",[v._v("集中式是将集群元数据（节点信息、故障等等）几种存储在某个节点上。集中式元数据集中存储的典型代表，比如 kafka, storm 等，底层基于 zookeeper（分布式协调的中间件）对所有元数据进行存储维护。")]),v._v(" "),_("p",[v._v("gossip 协议：所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。")]),v._v(" "),_("p",[v._v("redis cluster 节点间采用 gossip 协议进行通信。")]),v._v(" "),_("p",[v._v("集中式 和 gossip 协议 对比：")]),v._v(" "),_("ul",[_("li",[v._v("时效性比较 ：集中式更好")]),v._v(" "),_("li",[v._v("元数据的存储压力 ：gossip 协议 压力小")])])])}),[],!1,null,null,null);_.default=t.exports}}]);