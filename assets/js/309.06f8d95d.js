(window.webpackJsonp=window.webpackJsonp||[]).push([[309],{584:function(v,_,t){"use strict";t.r(_);var s=t(14),r=Object(s.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("总结：")]),v._v(" "),_("p",[v._v("1、缓存策略选择：Cache-aside pattern")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://muyids.oss-cn-beijing.aliyuncs.com/47e06ce80e77zoom-1.png",alt:"redis和mysql双写一致性问题"}})]),v._v(" "),_("h1",{attrs:{id:"谈谈一致性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#谈谈一致性"}},[v._v("#")]),v._v(" 谈谈一致性")]),v._v(" "),_("p",[v._v("一致性就是数据保持一致，在分布式系统中，可以理解为多个节点中数据的值是一致的。")]),v._v(" "),_("ul",[_("li",[v._v("强一致性：这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大")]),v._v(" "),_("li",[v._v("弱一致性：这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态")]),v._v(" "),_("li",[v._v("最终一致性：最终一致性是弱一致性的一个特例，系统会"),_("strong",[v._v("保证在一定时间内")]),v._v("，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型")])]),v._v(" "),_("p",[v._v("一致性问题不可避免，"),_("strong",[v._v("数据库和缓存双写，就必然会存在不一致的问题")]),v._v("。")]),v._v(" "),_("p",[v._v("答这个问题，先明白一个前提。就是如果对数据有强一致性要求，不能放缓存。我们所做的一切，只能保证最终一致性。")]),v._v(" "),_("p",[v._v("另外，我们所做的方案从根本上来说，只能说降低不一致发生的概率，无法完全避免。因此，"),_("strong",[v._v("有强一致性要求的数据，不能放缓存")]),v._v("。")]),v._v(" "),_("p",[v._v("回答：首先，采取正确更新策略，做两步操作："),_("strong",[v._v("删缓存")]),v._v("和"),_("strong",[v._v("更新数据库")]),v._v("。")]),v._v(" "),_("p",[v._v("但是这两步操作也是有问题的；不管是先写数据库，再删除缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("如果删除了缓存 Redis，还没有来得及写库 MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。（并发读写）")])]),v._v(" "),_("li",[_("p",[v._v("如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。（宕机）")])])]),v._v(" "),_("h2",{attrs:{id:"如何解决上面两步出现的问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何解决上面两步出现的问题"}},[v._v("#")]),v._v(" 如何解决上面两步出现的问题")]),v._v(" "),_("ol",[_("li",[v._v("延时双删策略")]),v._v(" "),_("li",[v._v("设置缓存的过期时间")])]),v._v(" "),_("h3",{attrs:{id:"延时双删策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#延时双删策略"}},[v._v("#")]),v._v(" 延时双删策略")]),v._v(" "),_("p",[v._v("在写库前后都进行"),_("code",[v._v("redis.del(key)")]),v._v("操作，并且设定合理的超时时间。具体步骤是：")]),v._v(" "),_("ol",[_("li",[v._v("先删除缓存")]),v._v(" "),_("li",[v._v("再写数据库")]),v._v(" "),_("li",[v._v("休眠 500 毫秒（根据具体的业务时间来定）")]),v._v(" "),_("li",[v._v("再次删除缓存。")])])])}),[],!1,null,null,null);_.default=r.exports}}]);