(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{305:function(v,_,t){"use strict";t.r(_);var r=t(14),l=Object(r.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("在开发高并发系统时有三把利器用来保护系统：缓存、降级和限流")]),v._v(" "),_("ul",[_("li",[v._v("缓存：缓存的目的是提升系统访问速度和增大系统处理容量")]),v._v(" "),_("li",[v._v("降级：降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行")]),v._v(" "),_("li",[v._v("限流：限流的目的是通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理")])]),v._v(" "),_("p",[v._v("常用限流算法：")]),v._v(" "),_("ul",[_("li",[v._v("计数器算法")]),v._v(" "),_("li",[v._v("滑动窗口")]),v._v(" "),_("li",[v._v("令牌桶算法")]),v._v(" "),_("li",[v._v("漏桶算法")])]),v._v(" "),_("h2",{attrs:{id:"计数器算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#计数器算法"}},[v._v("#")]),v._v(" 计数器算法")]),v._v(" "),_("p",[v._v("计数器算法是限流算法里最简单也是最容易实现的一种算法。")]),v._v(" "),_("p",[v._v("比如我们规定，对于 A 接口来说，我们 1 分钟的访问次数不能超过 100 个。那么我们可以这么做：在一开始的时候，我们可以设置一个计数器 counter，每当一个请求过来的时候，counter 就加 1，如果 counter 的值大于 100 并且该请求与第一个请求的间隔时间还在 1 分钟之内，那么说明请求数过多；如果该请求与第一个请求的间隔时间大于 1 分钟，且 counter 的值还在限流范围内，那么就重置 counter")]),v._v(" "),_("p",[v._v("计数器算法虽然简单，但是有一个十分致命的问题，那就是临界问题")]),v._v(" "),_("p",[v._v("假设有一个恶意用户，他在 0:59 时，瞬间发送了 100 个请求，并且 1:00 又瞬间发送了 100 个请求，那么其实这个用户在 1 秒里面，瞬间发送了 200 个请求。我们刚才规定的是 1 分钟最多 100 个请求，也就是每秒钟最多 1.7 个请求，用户通过在时间窗口的重置节点处突发请求， 可以瞬间超过我们的速率限制。用户有可能通过算法的这个漏洞，瞬间压垮我们的应用。")]),v._v(" "),_("p",[v._v("聪明的朋友可能已经看出来了，刚才的问题其实是因为我们统计的精度太低。那么如何很好地处理这个问题呢？或者说，如何将临界问题的影响降低呢？我们可以看下面的滑动窗口算法。")]),v._v(" "),_("h2",{attrs:{id:"滑动窗口"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口"}},[v._v("#")]),v._v(" 滑动窗口")]),v._v(" "),_("p",[v._v("滑动窗口，又称 rolling window。为了解决这个问题，我们引入了滑动窗口算法。如果学过 TCP 网络协议的话，那么一定对滑动窗口这个名词不会陌生")]),v._v(" "),_("p",[v._v("比如一个时间窗口就是一分钟, 然后我们将时间窗口进行划分，将滑动窗口划成了 6 格，所以每格代表的是 10 秒钟。每过 10 秒钟，我们的时间窗口就会往右滑动一格。每一个格子都有自己独立的计数器 counter，比如当一个请求 在 0:35 秒的时候到达，那么 0:30~0:39 对应的 counter 就会加 1。")]),v._v(" "),_("p",[v._v("我们可以发现，计数器算法其实就是滑动窗口算法。只是它没有对时间窗口做进一步地划分，所以只有 1 格。")]),v._v(" "),_("p",[v._v("由此可见，当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。")]),v._v(" "),_("h2",{attrs:{id:"令牌桶算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#令牌桶算法"}},[v._v("#")]),v._v(" 令牌桶算法")]),v._v(" "),_("p",[v._v("令牌桶算法是比较常见的限流算法之一，大概描述如下：")]),v._v(" "),_("ol",[_("li",[v._v("所有的请求在处理之前都需要拿到一个可用的令牌才会被处理；")]),v._v(" "),_("li",[v._v("根据限流大小，设置按照一定的速率往桶里添加令牌；")]),v._v(" "),_("li",[v._v("桶设置最大的放置令牌限制，当桶满时、新添加的令牌就被丢弃或者拒绝；")]),v._v(" "),_("li",[v._v("请求达到后首先要获取令牌桶中的令牌，拿着令牌才可以进行其他的业务逻辑，处理完业务逻辑之后，将令牌直接删除；")])])])}),[],!1,null,null,null);_.default=l.exports}}]);