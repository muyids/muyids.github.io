(window.webpackJsonp=window.webpackJsonp||[]).push([[268],{543:function(v,_,i){"use strict";i.r(_);var t=i(14),l=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("ul",[_("li",[v._v("事务")]),v._v(" "),_("li",[v._v("隔离级别")]),v._v(" "),_("li",[v._v("脏读、不可重复读、幻读这些问题 如何解决？")]),v._v(" "),_("li")]),v._v(" "),_("h2",{attrs:{id:"事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[v._v("#")]),v._v(" 事务")]),v._v(" "),_("h3",{attrs:{id:"acid-属性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#acid-属性"}},[v._v("#")]),v._v(" ACID 属性")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("原子性（atomicity)")]),v._v(" "),_("ul",[_("li",[v._v("要么全部成功，要么全部失败，不可能只执行一部分操作")])])]),v._v(" "),_("li",[_("p",[v._v("一致性（consistency)")]),v._v(" "),_("ul",[_("li",[v._v("系统(数据库)总是从一个一致性的状态转移到另一个一致性的状态，不会存在中间状态")])])]),v._v(" "),_("li",[_("p",[v._v("隔离性（isolation） - 4 个隔离级别")]),v._v(" "),_("ul",[_("li",[v._v("通常来说：一个事务在完全提交之前，对其他事务是不可见的。也有例外情况")])])]),v._v(" "),_("li",[_("p",[v._v("持久性（durability）")]),v._v(" "),_("ul",[_("li",[v._v("一旦事务提交，那么就永远是这样子了，哪怕系统崩溃也不会影响到这个事务的结果")])])])]),v._v(" "),_("p",[v._v("转账业务：A 给 B 转账 1000 元看作一个事务，账户 A 要 -1000，账户 B 要 + 1000；")]),v._v(" "),_("p",[v._v("对于同一时刻仅有一个事务处理的场景（串行化），上面业务不会发生问题；")]),v._v(" "),_("p",[v._v("但是，如果存在多事务并发的情况，会引发一些问题，如：脏读、不可重复读、幻读。")]),v._v(" "),_("h2",{attrs:{id:"隔离级别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#隔离级别"}},[v._v("#")]),v._v(" 隔离级别")]),v._v(" "),_("p",[v._v("本质（目的）：隔离级别是为了 控制读取数据的时机。")]),v._v(" "),_("h2",{attrs:{id:"脏读、不可重复读、幻读这些问题-如何解决"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#脏读、不可重复读、幻读这些问题-如何解决"}},[v._v("#")]),v._v(" 脏读、不可重复读、幻读这些问题 如何解决？")]),v._v(" "),_("p",[v._v("这些问题都是因为 多事务的并发进行造成的。")]),v._v(" "),_("p",[v._v("先明确 这几个问题是什么：")]),v._v(" "),_("ul",[_("li",[v._v("脏读：A 事务读取到了 B 事务**"),_("em",[v._v("未提交")]),v._v("**的内容，而 B 事务后面进行了回滚")]),v._v(" "),_("li",[v._v("不可重复读：当设置 A 事务只能读取 B 事务已经提交的部分，会造成在 A 事务内的两次查询，结果竟然不一样，因为在此期间 B 事务进行了提交操作")]),v._v(" "),_("li",[v._v("幻读："),_("strong",[v._v("仅专指“新插入的行”")]),v._v('；A 事务读取了一个范围的内容，而同时 B 事务在此期间插入了一条数据，然后 A 又发现了 B 新插入的数据，造成"幻觉"')])]),v._v(" "),_("p",[v._v("两种解决方案：")]),v._v(" "),_("ol",[_("li",[v._v("读操作利用 MVCC ，写操作进行加锁\n"),_("ol",[_("li",[v._v("读操作：只能读到 生成 ReadView 之前提交的事务所做的更改；生成 ReadView 之前未提交的事务 或 之后才开启的事务所做的 更改是看不到的。")]),v._v(" "),_("li",[v._v("写操作：针对的是 最新版本的记录；读操作针对的历史版本和改动记录针对的最新版本并不冲突，所以 采用 MVCC 时，读写不冲突")])])]),v._v(" "),_("li",[v._v("读、写操作都 加锁\n"),_("ol",[_("li",[v._v("读写操作：某些业务场景不允许读取记录的旧版本，比如 银行存款业务")])])])]),v._v(" "),_("p",[v._v("不同隔离级别下的 MVCC：（生成 ReadView 的时间不一样）")]),v._v(" "),_("ul",[_("li",[v._v("在 READ COMMITTED 隔离级别下，一个事务在执行过程中"),_("strong",[v._v("每次执行 SELECT 操作")]),v._v("时都会生成一个 ReadView，ReadView 的存在本身就保证了事务不可以读取到未提交的事务所做的更改，也就是避免了脏读现象；")]),v._v(" "),_("li",[v._v("REPEATABLE READ 隔离级别下，一个事务在执行过程中"),_("strong",[v._v("只有第一次执行 SELECT 操作")]),v._v("才会生成一个 ReadView，之后的 SELECT 操作都复用这个 ReadView，这样也就避免了不可重复读的问题")])])])}),[],!1,null,null,null);_.default=l.exports}}]);