(window.webpackJsonp=window.webpackJsonp||[]).push([[270],{542:function(_,v,a){"use strict";a.r(v);var t=a(14),e=Object(t.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("p",[_._v("在高负载情况下，MySQL 性能可能会受到影响。以下是一些常见的 MySQL 性能优化技巧：")]),_._v(" "),v("h2",{attrs:{id:"数据库查询优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据库查询优化"}},[_._v("#")]),_._v(" 数据库查询优化")]),_._v(" "),v("ol",[v("li"),_._v(" "),v("li",[_._v("优化 SQL 语句：编写高效的 SQL 语句可以提高 MySQL 性能。使用 EXPLAIN 命令可以帮助识别 SQL 语句中的慢查询。\n"),v("ol",[v("li",[_._v("分页优化：延迟关联，书签方式")]),_._v(" "),v("li",[_._v("索引优化：覆盖索引(避免回表)，最左原则，前缀索引(邮箱，用户名等前几位)，小表驱动大表\n"),v("ol",[v("li",[_._v("使用索引：索引可以加速数据库查询，因此在查询常用的列时应该为它们创建索引。但是，过多的索引会影响写入性能，因此需要权衡索引的数量和性能之间的平衡。")]),_._v(" "),v("li",[_._v("优化查询：避免使用 SELECT *语句，因为它会使查询变得缓慢。只选择需要的列。尽可能使用 INNER JOIN 或 LEFT JOIN，避免使用子查询。使用 WHERE 条件约束查询范围。")])])]),_._v(" "),v("li",[_._v("慢查询日志：explain 查看执行计划，关注有没有用索引，索引的类型")])])]),_._v(" "),v("li",[_._v("优化缓存：使用缓存可以减少数据库查询次数，从而提高性能。MySQL 本身提供了查询缓存功能，但是在高并发环境下可能会导致性能下降。")]),_._v(" "),v("li",[_._v("使用连接池：使用连接池可以减少连接 MySQL 的开销，从而提高性能。")]),_._v(" "),v("li",[_._v("监控性能：定期监控 MySQL 的性能可以及时发现性能问题，并采取相应的措施。MySQL 提供了一些内置的监控工具，例如 SHOW STATUS 和 SHOW PROCESSLIST 命令。")])]),_._v(" "),v("h2",{attrs:{id:"数据库设计优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据库设计优化"}},[_._v("#")]),_._v(" 数据库设计优化")]),_._v(" "),v("ol",[v("li",[_._v("优化表结构：使用适当的数据类型和表结构可以提高性能。例如，使用整数类型来存储 ID，使用 CHAR 类型来存储定长字符串等。")]),_._v(" "),v("li",[_._v("分离读写：将读写操作分离到不同的服务器上，可以提高 MySQL 的性能。读操作可以在主服务器上执行，而写操作可以在从服务器上执行。")])]),_._v(" "),v("h2",{attrs:{id:"配置运维"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#配置运维"}},[_._v("#")]),_._v(" 配置运维")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("优化服务器配置：调整服务器参数可以提高 MySQL 性能。例如，增加缓冲区大小、调整连接超时时间等。")])]),_._v(" "),v("li",[v("p",[_._v("定期优化数据库：定期优化数据库可以清除无用数据、重建索引等操作，从而提高性能。可以使用 MySQL 自带的 OPTIMIZE TABLE 命令。")])])]),_._v(" "),v("p",[v("strong",[_._v("SQL 优化")])]),_._v(" "),v("ul",[v("li",[_._v("分页优化：延迟关联，书签方式")]),_._v(" "),v("li",[_._v("索引优化：覆盖索引(避免回表)，最左原则，前缀索引(邮箱，用户名等前几位)，小表驱动大表")]),_._v(" "),v("li",[_._v("慢查询日志：explain 查看执行计划，关注有没有用索引，索引的类型")])]),_._v(" "),v("p",[v("strong",[_._v("库表设计优化:")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("禁止使用 NULL")])]),_._v(" "),v("li",[v("p",[_._v("合适的数据类型")])]),_._v(" "),v("li",[v("p",[_._v("数据长度尽量小")])]),_._v(" "),v("li",[v("p",[_._v("分库分表策略\n"),v("strong",[_._v("硬件扩展：")])])]),_._v(" "),v("li",[v("p",[_._v("scale-up 垂直扩展：提高单机性能")])]),_._v(" "),v("li",[v("p",[_._v("scale-out 横向扩展：主从，分库分表")])])]),_._v(" "),v("p",[v("strong",[_._v("软件扩展：")])]),_._v(" "),v("ul",[v("li",[_._v("分库分表：range, hash, 基因法")])]),_._v(" "),v("h2",{attrs:{id:"sql-优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#sql-优化"}},[_._v("#")]),_._v(" SQL 优化")]),_._v(" "),v("h3",{attrs:{id:"分页优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分页优化"}},[_._v("#")]),_._v(" 分页优化")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("延迟关联")]),_._v(" "),v("p",[_._v("先通过 where 条件提取出主键，在将该表与原数据表关联，通过主键 id 提取数据行，而不是通过原来的二级索引提取数据行")]),_._v(" "),v("p",[_._v("select a.* from table a, (select id from table where type = 2 and level = 9 order by id asc limit 190289,10 ) b where a.id = b.id")])]),_._v(" "),v("li",[v("p",[_._v("书签方式")]),_._v(" "),v("p",[_._v("书签方式说白了就是找到 limit 第一个参数对应的主键值，再根据这个主键值再去过滤并 limit")])])]),_._v(" "),v("h3",{attrs:{id:"索引优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引优化"}},[_._v("#")]),_._v(" 索引优化")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("正确使用索引")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("建立覆盖索引")]),_._v(" "),v("p",[_._v("InnoDB 使用辅助索引查询数据时会回表，但是如果索引的叶节点中已经包含要查询的字段，那它没有必要再回表查询了，这就叫覆盖索引")]),_._v(" "),v("p",[_._v("例如对于如下查询：")]),_._v(" "),v("p",[_._v("select name from test where city='上海'")]),_._v(" "),v("p",[_._v("我们将被查询的字段建立到联合索引中，这样查询结果就可以直接从索引中获取")]),_._v(" "),v("p",[_._v("alter table test add index idx_city_name (city, name);")])]),_._v(" "),v("li",[v("p",[_._v("避免在 where 查询条件中使用 != 或者 <> 操作符")]),_._v(" "),v("p",[_._v("SQL 中，不等于操作符会导致查询引擎放弃索引索引，引起全表扫描，即使比较的字段上有索引")]),_._v(" "),v("p",[_._v("解决方法：通过把不等于操作符改成 or，可以使用索引，避免全表扫描")]),_._v(" "),v("p",[_._v("例如，把 column<>’aaa’，改成 column>’aaa’ or column<’aaa’ ，就可以使用索引了")])]),_._v(" "),v("li",[v("p",[_._v("适当使用前缀索引")]),_._v(" "),v("p",[_._v("MySQL 是支持前缀索引的，也就是说我们可以定义字符串的一部分来作为索引")]),_._v(" "),v("p",[_._v("我们知道索引越长占用的磁盘空间就越大，那么在相同数据页中能放下的索引值也就越少，这就意味着搜索索引需要的查询时间也就越长，进而查询的效率就会降低，所以我们可以适当的选择使用前缀索引，以减少空间的占用和提高查询效率")]),_._v(" "),v("p",[_._v("比如，邮箱的后缀都是固定的“@xxx.com”，那么类似这种后面几位为固定值的字段就非常适合定义为前缀索引")]),_._v(" "),v("p",[_._v("alter table test add index index2(email(6));")]),_._v(" "),v("p",[_._v("使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本")]),_._v(" "),v("p",[_._v("需要注意的是，前缀索引也存在缺点，MySQL 无法利用前缀索引做 order by 和 group by 操作，也无法作为覆盖索引")])]),_._v(" "),v("li",[v("p",[_._v("查询具体的字段而非全部字段")]),_._v(" "),v("p",[_._v("要尽量避免使用 select *，而是查询需要的字段，这样可以提升速度，以及减少网络传输的带宽压力")])])])]),_._v(" "),v("li",[v("p",[_._v("正确使用联合索引")]),_._v(" "),v("p",[_._v("使用了 B+ 树的 MySQL 数据库引擎，比如 InnoDB 引擎，在每次查询复合字段时是从左往右匹配数据的，因此在创建联合索引的时候需要注意索引创建的顺序")]),_._v(" "),v("p",[_._v("例如，我们创建了一个联合索引是 idx(name,age,sex)，那么当我们使用，姓名+年龄+性别、姓名+年龄、姓名等这种最左前缀查询条件时，就会触发联合索引进行查询；然而如果非最左匹配的查询条件，例如，性别+姓名这种查询条件就不会触发联合索")])]),_._v(" "),v("li",[v("p",[_._v("不要在列上进行运算操作")]),_._v(" "),v("p",[_._v("不要在列字段上进行算术运算或其他表达式运算，否则可能会导致查询引擎无法正确使用索引，从而影响了查询的效率")]),_._v(" "),v("p",[_._v("select _ from test where id + 1 = 50;\nselect _ from test where month(updateTime) = 7;")])])]),_._v(" "),v("h3",{attrs:{id:"join-优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#join-优化"}},[_._v("#")]),_._v(" Join 优化")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("尽可能减少嵌套循环的循环次数")]),_._v(" "),v("p",[_._v("一个显著优化方式是对被驱动表的 join 字段建立索引，利用索引能快速匹配到对应的行，避免与内层表每一行记录做比较，极大地减少总循环次数。另一个优化点，就是连接时用小结果集驱动大结果集，在索引优化的基础上能进一步减少嵌套循环的次数")])]),_._v(" "),v("li",[v("p",[_._v("避免使用 JOIN 关联太多的表")])]),_._v(" "),v("li",[v("p",[_._v("优化子查询")]),_._v(" "),v("p",[_._v("尽量使用 Join 语句来替代子查询，因为子查询是嵌套查询，而嵌套查询会新创建一张临时表，而临时表的创建与销毁会占用一定的系统资源以及花费一定的时间，同时对于返回结果集比较大的子查询，其对查询性能的影响更大")])]),_._v(" "),v("li",[v("p",[_._v("小表驱动大表")]),_._v(" "),v("p",[_._v("我们要尽量使用小表驱动大表的方式进行查询，也就是如果 B 表的数据小于 A 表的数据，那执行的顺序就是先查 B 表再查 A 表，具体查询语句如下：")]),_._v(" "),v("p",[_._v("select name from A where id in (select id from B);")])]),_._v(" "),v("li",[v("p",[_._v("防止隐式类型转换")]),_._v(" "),v("p",[_._v("select * from test where skuId=123456")]),_._v(" "),v("p",[_._v("skuId 这个字段上有索引，但是 explain 的结果却显示这条语句会全表扫描")]),_._v(" "),v("p",[_._v("原因在于 skuId 的字符类型是 varchar(32)，比较值却是整型，故需要做类型转换")])]),_._v(" "),v("li",[v("p",[_._v("适当增加冗余字段")]),_._v(" "),v("p",[_._v("增加冗余字段可以减少大量的连表查询，因为多张表的连表查询性能很低，所有可以适当的增加冗余字段，以减少多张表的关联查询，这是以空间换时间的优化策略")]),_._v(" "),v("p",[_._v("缺点，可能造成数据不一致")])])]),_._v(" "),v("h3",{attrs:{id:"排序优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#排序优化"}},[_._v("#")]),_._v(" 排序优化")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("利用索引扫描做排序")]),_._v(" "),v("p",[_._v("MySQL 有两种方式生成有序结果：其一是对结果集进行排序的操作，其二是按照索引顺序扫描得出的结果自然是有序的")]),_._v(" "),v("p",[_._v("但是如果索引不能覆盖查询所需列，就不得不每扫描一条记录回表查询一次，这个读操作是随机 IO，通常会比顺序全表扫描还慢")]),_._v(" "),v("p",[_._v("因此，在设计索引时，尽可能使用同一个索引既满足排序又用于查找行")]),_._v(" "),v("p",[_._v("例如：")]),_._v(" "),v("p",[_._v("--建立索引（date,staff_id,customer_id）\nselect staff_id, customer_id from test where date = '2010-01-01' order by staff_id,customer_id;\n只有当索引的列顺序和 ORDER BY 子句的顺序完全一致，并且所有列的排序方向都一样时，才能够使用索引来对结果做排序")])])]),_._v(" "),v("h3",{attrs:{id:"union-优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#union-优化"}},[_._v("#")]),_._v(" UNION 优化")]),_._v(" "),v("p",[_._v("MySQL 处理 union 的策略是先创建临时表，然后将各个查询结果填充到临时表中最后再来做查询，很多优化策略在 union 查询中都会失效，因为它无法利用索引")]),_._v(" "),v("p",[_._v("最好手工将 where、limit 等子句下推到 union 的各个子查询中，以便优化器可以充分利用这些条件进行优化")]),_._v(" "),v("p",[_._v("此外，除非确实需要服务器去重，一定要使用 union all，如果不加 all 关键字，MySQL 会给临时表加上 distinct 选项，这会导致对整个临时表做唯一性检查，代价很高")]),_._v(" "),v("h3",{attrs:{id:"慢查询日志"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#慢查询日志"}},[_._v("#")]),_._v(" 慢查询日志")]),_._v(" "),v("p",[_._v("出现慢查询通常的排查手段是先使用慢查询日志功能，查询出比较慢的 SQL 语句，然后再通过 Explain 来查询 SQL 语句的执行计划，最后分析并定位出问题的根源，再进行处理")]),_._v(" "),v("p",[_._v("慢查询日志指的是在 MySQL 中可以通过配置来开启慢查询日志的记录功能，超过 long_query_time 值的 SQL 将会被记录在日志中")]),_._v(" "),v("p",[_._v("我们可以通过设置“slow_query_log=1”来开启慢查询")]),_._v(" "),v("p",[_._v("需要注意的是，在开启慢日志功能之后，会对 MySQL 的性能造成一定的影响，因此在生产环境中要慎用此功能")]),_._v(" "),v("h2",{attrs:{id:"设计优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#设计优化"}},[_._v("#")]),_._v(" 设计优化")]),_._v(" "),v("h3",{attrs:{id:"避免使用-null"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#避免使用-null"}},[_._v("#")]),_._v(" 避免使用 NULL")]),_._v(" "),v("p",[_._v("NULL 在 MySQL 中不好处理，存储需要额外空间，运算也需要特殊的运算符，含有 NULL 的列很难进行查询优化")]),_._v(" "),v("p",[_._v("应当指定列为 not null，用 0、空串或其他特殊的值代替空值，比如定义为 int not null default 0")]),_._v(" "),v("h3",{attrs:{id:"最小数据长度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#最小数据长度"}},[_._v("#")]),_._v(" 最小数据长度")]),_._v(" "),v("p",[_._v("越小的数据类型长度通常在磁盘、内存和 CPU 缓存中都需要更少的空间，处理起来更快")]),_._v(" "),v("h3",{attrs:{id:"使用最简单数据类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用最简单数据类型"}},[_._v("#")]),_._v(" 使用最简单数据类型")]),_._v(" "),v("p",[_._v("简单的数据类型操作代价更低，比如：能使用 int 类型就不要使用 varchar 类型，因为 int 类型比 varchar 类型的查询效率更高")]),_._v(" "),v("h3",{attrs:{id:"尽量少定义-text-类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#尽量少定义-text-类型"}},[_._v("#")]),_._v(" 尽量少定义 text 类型")]),_._v(" "),v("h3",{attrs:{id:"适当分表、分库策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#适当分表、分库策略"}},[_._v("#")]),_._v(" 适当分表、分库策略")]),_._v(" "),v("p",[_._v("详细参考下面关于分库分表的概述")]),_._v(" "),v("h3",{attrs:{id:"常见类型选择"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见类型选择"}},[_._v("#")]),_._v(" 常见类型选择")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("整数类型宽度设置")]),_._v(" "),v("p",[_._v("MySQL 可以为整数类型指定宽度，例如 int(11)，实际上并没有意义，它并不会限制值的范围，对于存储和计算来说，int(1)和 int(20)是相同的")])]),_._v(" "),v("li",[v("p",[_._v("VARCHAR 和 CHAR 类型")]),_._v(" "),v("p",[_._v("char 类型是定长的，而 varchar 存储可变字符串，比定长更省空间，但是 varchar 需要额外 1 或 2 个字节记录字符串长度，更新时也容易产生碎片")]),_._v(" "),v("p",[_._v("需要结合使用场景来选择：如果字符串列最大长度比平均长度大很多，或者列的更新很少，选择 varchar 较合适；如果要存很短的字符串，或者字符串值长度都相同，比如 MD5 值，或者列数据经常变更，选择使用 char 类型")])]),_._v(" "),v("li",[v("p",[_._v("DATETIME 和 TIMESTAMP 类型\ndatetime 的范围更大，能表示从 1001 到 9999 年，timestamp 只能表示从 1970 年到 2038 年。datetime 与时区无关，timestamp 显示值依赖于时区。在大多数场景下，这两种类型都能良好地工作，但是建议使用 timestamp，因为 datetime 占用 8 个字节，timestamp 只占用了 4 个字节，timestamp 空间效率更高")])]),_._v(" "),v("li",[v("p",[_._v("BLOB 和 TEXT 类型")]),_._v(" "),v("p",[_._v("blob 和 text 都是为存储很大数据而设计的字符串数据类型，分别采用二进制和字符方式存储")]),_._v(" "),v("p",[_._v("在实际使用中，要慎用这两种类型，它们的查询效率很低，如果字段必须要使用这两种类型，可以把此字段分离成子表，需要查询此字段时使用联合查询，这样可以提高主表的查询效率")])])]),_._v(" "),v("h3",{attrs:{id:"范式化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#范式化"}},[_._v("#")]),_._v(" 范式化")]),_._v(" "),v("p",[_._v("当数据较好范式化时，修改的数据更少，而且范式化的表通常要小，可以有更多的数据缓存在内存中，所以执行操作会更快")]),_._v(" "),v("p",[_._v("缺点则是查询时需要更多的关联")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("第一范式")]),_._v(" "),v("p",[_._v("字段不可分割，数据库默认支持")])]),_._v(" "),v("li",[v("p",[_._v("第二范式")]),_._v(" "),v("p",[_._v("消除对主键的部分依赖，可以在表中加上一个与业务逻辑无关的字段作为主键，比如用自增 id")])]),_._v(" "),v("li",[v("p",[_._v("第三范式")]),_._v(" "),v("p",[_._v("消除对主键的传递依赖，可以将表拆分，减少数据冗余")])])]),_._v(" "),v("h2",{attrs:{id:"高扩展-硬件优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#高扩展-硬件优化"}},[_._v("#")]),_._v(" 高扩展（硬件优化）")]),_._v(" "),v("h3",{attrs:{id:"scale-up"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#scale-up"}},[_._v("#")]),_._v(" scale-up")]),_._v(" "),v("p",[_._v("向上扩展或者纵向扩展，主要是提供比现在服务器更好性能的服务器，比如增加 CPU 和内存以及磁盘阵列等")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("磁盘")]),_._v(" "),v("p",[_._v("磁盘应该尽量使用有高性能读写能力的磁盘，比如固态硬盘，这样就可以减少 I/O 运行的时间，从而提高了 MySQL 整体的运行效率")]),_._v(" "),v("p",[_._v("磁盘也可以尽量使用多个小磁盘而不是一个大磁盘，因为磁盘的转速是固定的，有多个小磁盘就相当于拥有多个并行运行的磁盘一样")])]),_._v(" "),v("li",[v("p",[_._v("网络")]),_._v(" "),v("p",[_._v("保证网络带宽的通畅（低延迟）以及够大的网络带宽是 MySQL 正常运行的基本条件，如果条件允许的话也可以设置多个网卡，以提高网络高峰期 MySQL 服务器的运行效率")])]),_._v(" "),v("li",[v("p",[_._v("内存")]),_._v(" "),v("p",[_._v("MySQL 服务器的内存越大，那么存储和缓存的信息也就越多，而内存的性能是非常高的，从而提高了整个 MySQL 的运行效率")])])]),_._v(" "),v("h3",{attrs:{id:"scale-out"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#scale-out"}},[_._v("#")]),_._v(" scale-out")]),_._v(" "),v("p",[_._v("向外扩展或者横向扩展，是指增加服务器数量的扩展，这样主要能分散各个服务器的压力")]),_._v(" "),v("ul",[v("li",[_._v("主从")])]),_._v(" "),v("h2",{attrs:{id:"分库分表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分库分表"}},[_._v("#")]),_._v(" 分库分表")]),_._v(" "),v("h3",{attrs:{id:"问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[_._v("#")]),_._v(" 问题")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("用户请求量太大")]),_._v(" "),v("p",[_._v("单服务器 TPS、内存、IO 都是有上限的，需要将请求打散分布到多个服务器")])]),_._v(" "),v("li",[v("p",[_._v("单库数据量太大")]),_._v(" "),v("p",[_._v("单个数据库处理能力有限；单库所在服务器的磁盘空间有限；单库上的操作 IO 有瓶颈")])]),_._v(" "),v("li",[v("p",[_._v("单表数据量太大")]),_._v(" "),v("p",[_._v("查询、插入、更新操作都会变慢，在加字段、加索引、机器迁移都会产生高负载，影响服务")])])]),_._v(" "),v("h3",{attrs:{id:"垂直拆分-scale-up"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垂直拆分-scale-up"}},[_._v("#")]),_._v(" 垂直拆分 scale-up")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("垂直分库")]),_._v(" "),v("p",[_._v("微服务架构时，业务切割得足够独立，数据也会按照业务切分，保证业务数据隔离，大大提 升了数据库的吞吐能力")])]),_._v(" "),v("li",[v("p",[_._v("垂直分表")]),_._v(" "),v("p",[_._v("表中字段太多 或者 包含大字段的时候，建议垂直分表；")]),_._v(" "),v("p",[_._v("单行数据过大产生问题：在查询时对数据库的 IO、内存会受到影响，同时更新数据时，产生的 binlog 文件会很大，MySQL 在主从同步时也会有延迟的风险")]),_._v(" "),v("p",[_._v("实际场景：用户表，一般会拆分为用户基础信息，用户鉴权信息，用户业务信息几张子表")])])]),_._v(" "),v("h3",{attrs:{id:"水平拆分-scale-out"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#水平拆分-scale-out"}},[_._v("#")]),_._v(" 水平拆分 scale-out")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("水平分库")]),_._v(" "),v("p",[_._v("将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合 不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破 IO、连接数、硬件 资源等的瓶颈")]),_._v(" "),v("p",[_._v("水平分库规则")]),_._v(" "),v("p",[_._v("不跨库、不跨表，保证同一类的数据都在同一个服务器上面。 数据在切分之前，需要考虑如何高效的进行数据获取，如果每次查询都要跨越多个节点，就需要谨 慎使用。")])]),_._v(" "),v("li",[v("p",[_._v("水平分表")]),_._v(" "),v("p",[_._v("针对数据量巨大的单张表（比如订单表），按照规则把一张表的数据切分到多张表里面去。 但是这些表还是在同一个库中，所以库级别的数据库操作还是有 IO 瓶颈")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("水平分表规则")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("RANGE")]),_._v(" "),v("p",[_._v("时间：按照年、月、日去切分。例如 order_2020、order_202005、order_20200501\n地域：按照省或市去切分。例如 order_beijing、order_shanghai、order_chengdu\n大小：从 0 到 1000000 一个表。例如 1000001-2000000 放一个表，每 100 万放一个表")])]),_._v(" "),v("li",[v("p",[_._v("HASH")]),_._v(" "),v("p",[_._v("根据用户 ID 取模，不同的业务使用的切分规则是不一样，就上面提到的切分规则，举例如下：")]),_._v(" "),v("p",[_._v("站内信\n用户维度：用户只能看到发送给自己的消息，其他用户是不可见的，这种情况下是按照 用户 ID hash 分库，在用户查看历史记录翻页查询时，所有的查询请求都在同一个库内\n用户表")]),_._v(" "),v("p",[_._v("范围法：以用户 ID 为划分依据，将数据水平切分到两个数据库实例，如：1 到 1000W 在一张表，1000W 到 2000W 在一张表，这种情况会出现单表的负载较高")]),_._v(" "),v("p",[_._v("按照用户 ID HASH 尽量保证用户数据均衡分到数据库中\n如果在登录场景下，用户输入手机号和验证码进行登录，这种情况下，登录时是不是需要扫描所有分库的信息？ 最终方案：用户信息采用 ID 做切分处理，同时存储用户 ID 和手机号的映射的关系表（新增一个关系表），关系表采用手机号进行切分。可以通过关系表根据手机号查询到对应的 ID，再定位用户信息。")])])])])])])]),_._v(" "),v("h3",{attrs:{id:"技术方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#技术方案"}},[_._v("#")]),_._v(" 技术方案")]),_._v(" "),v("ul",[v("li",[_._v("sharding-jdbc")]),_._v(" "),v("li",[_._v("MyCat")])])])}),[],!1,null,null,null);v.default=e.exports}}]);