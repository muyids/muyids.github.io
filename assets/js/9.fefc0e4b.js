(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{284:function(t,a,s){"use strict";s.r(a);var r=s(14),_=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("锁机制经常用于业务场景中的并发控制，那么锁应该怎么用呢？")]),t._v(" "),a("h2",{attrs:{id:"为什么需要锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要锁"}},[t._v("#")]),t._v(" 为什么需要锁")]),t._v(" "),a("p",[t._v("锁机制经常用于业务场景中的并发控制")]),t._v(" "),a("p",[t._v("在多用户环境中，在同一时间可能会有多个用户更新相同的记录，这会产生冲突。这就是著名的并发性问题。")]),t._v(" "),a("h2",{attrs:{id:"典型的冲突"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#典型的冲突"}},[t._v("#")]),t._v(" 典型的冲突")]),t._v(" "),a("h3",{attrs:{id:"丢失更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#丢失更新"}},[t._v("#")]),t._v(" 丢失更新")]),t._v(" "),a("p",[t._v("一个事务的更新覆盖了其它事务的更新结果，就是所谓的更新丢失。")]),t._v(" "),a("p",[t._v("例如：用户 A 把值从 6 改为 2，用户 B 把值从 2 改为 6，则用户 A 丢失了他的更新。")]),t._v(" "),a("h3",{attrs:{id:"脏读"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#脏读"}},[t._v("#")]),t._v(" 脏读")]),t._v(" "),a("p",[t._v("当一个事务读取其它完成一半事务的记录时，就会发生脏读取。")]),t._v(" "),a("p",[t._v("例如：用户 A,B 看到的值都是 6，用户 B 把值改为 2，用户 A 读到的值仍为 6。")]),t._v(" "),a("p",[a("strong",[t._v("为了解决这些并发带来的问题。 我们需要引入并发控制机制。")])]),t._v(" "),a("h2",{attrs:{id:"悲观锁-pessimistic-lock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#悲观锁-pessimistic-lock"}},[t._v("#")]),t._v(" 悲观锁(Pessimistic Lock)")]),t._v(" "),a("p",[t._v("假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。")]),t._v(" "),a("p",[t._v("顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。\n传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。\n悲观锁，可以解决丢失更新和脏读问题")]),t._v(" "),a("h2",{attrs:{id:"乐观锁-optimistic-lock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#乐观锁-optimistic-lock"}},[t._v("#")]),t._v(" 乐观锁(Optimistic Lock)")]),t._v(" "),a("p",[t._v("假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。")]),t._v(" "),a("p",[t._v("顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，\n可以使用版本号或 timestamp 等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于 write_condition 机制的其实都是提供的乐观锁。\n乐观锁，不能解决脏读的问题。")]),t._v(" "),a("h2",{attrs:{id:"取舍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#取舍"}},[t._v("#")]),t._v(" 取舍")]),t._v(" "),a("p",[t._v("两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。\n但如果经常产生冲突，上层应用会不断的进行 retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。\n在实际生产环境里边,如果并发量不大且不允许脏读，可以使用悲观锁解决并发问题；但如果系统的并发非常大的话,悲观锁定会带来非常大的性能问题,所以我们就要选择乐观锁定的方法。")]),t._v(" "),a("h2",{attrs:{id:"cas-算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cas-算法"}},[t._v("#")]),t._v(" CAS 算法")]),t._v(" "),a("p",[t._v("乐观锁用到的机制就是 CAS 操作，Compare & Set，或是 Compare & Swap")]),t._v(" "),a("p",[t._v("CAS 有 3 个操作数，内存值 V，旧的预期值 A，要修改的新值 B。\n当且仅当预期值 A 和内存值 V 相同时，将内存值 V 修改为 B，否则什么都不做。")])])}),[],!1,null,null,null);a.default=_.exports}}]);