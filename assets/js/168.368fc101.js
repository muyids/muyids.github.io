(window.webpackJsonp=window.webpackJsonp||[]).push([[168],{442:function(v,_,t){"use strict";t.r(_);var a=t(14),r=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"常见的垃圾回收算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见的垃圾回收算法"}},[v._v("#")]),v._v(" 常见的垃圾回收算法")]),v._v(" "),_("p",[_("strong",[v._v("1、标记清除")])]),v._v(" "),_("p",[v._v("每次要回收的空间先进行标记，然后一次性清除")]),v._v(" "),_("p",[v._v("缺点：会产生大量的内存碎片")]),v._v(" "),_("p",[_("strong",[v._v("2、标记整理")])]),v._v(" "),_("p",[v._v("把有效的内存整理到一起，然后清理无效内存区")]),v._v(" "),_("p",[v._v("好处：解决内存碎片问题")]),v._v(" "),_("p",[v._v("缺点：效率低")]),v._v(" "),_("p",[_("strong",[v._v("3、复制")])]),v._v(" "),_("p",[v._v("复制：开辟两块大小相同的内存空间互相复制；比如：survivor 区 from，to 之间就用的复制")]),v._v(" "),_("p",[v._v("好处：效率高，没碎片，适合朝生夕死 的内存区域")]),v._v(" "),_("p",[v._v("缺点：内存利用率较低，不适合在对象存活率较高的老年代使用")]),v._v(" "),_("p",[_("strong",[v._v("4、分代回收算法")])]),v._v(" "),_("p",[v._v("jvm 使用的是分代回收算法")]),v._v(" "),_("p",[v._v("对于新生代，使用复制算法；")]),v._v(" "),_("h2",{attrs:{id:"什么是-gc-roots"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是-gc-roots"}},[v._v("#")]),v._v(" 什么是 GC Roots")]),v._v(" "),_("p",[v._v("垃圾：内存中已不再被使用的空间")]),v._v(" "),_("p",[v._v("垃圾回收时如何确定垃圾，根可达算法")]),v._v(" "),_("p",[v._v("<1>引用计数法：无法解决循环引用的问题")]),v._v(" "),_("p",[v._v("<2>可达性分析：")]),v._v(" "),_("p",[v._v("①GC Root 的对象作为起始点，从这个对象开始向下搜，如果没有任何引用链时，说明此对象不可用")]),v._v(" "),_("p",[v._v("② 哪些对象可以作为 GC Roots set 对象")]),v._v(" "),_("ul",[_("li",[v._v("虚拟机栈（栈帧中的局部变量区）中引用的对象")]),v._v(" "),_("li",[v._v("本地方法栈中 JNI 引用的对象")]),v._v(" "),_("li",[v._v("方法区中的类静态属性引用 的对象")]),v._v(" "),_("li",[v._v("方法区中常量引用的对象")])]),v._v(" "),_("h3",{attrs:{id:"对象引用的分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对象引用的分类"}},[v._v("#")]),v._v(" 对象引用的分类")]),v._v(" "),_("p",[v._v("强软弱虚")]),v._v(" "),_("p",[v._v("1）强引用：溢出都不回收，程序中普遍存在的对象引用")]),v._v(" "),_("p",[v._v("2）软引用：内存溢出前回收")]),v._v(" "),_("p",[v._v("3、弱引用：下一次 gc 时回收")]),v._v(" "),_("h2",{attrs:{id:"什么情况会发生-fullgc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么情况会发生-fullgc"}},[v._v("#")]),v._v(" 什么情况会发生 fullGC")]),v._v(" "),_("p",[v._v("1、System.gc()方法的调用")]),v._v(" "),_("p",[v._v("2、老年代空间不足")]),v._v(" "),_("p",[v._v("3、方法区（永生区）空间不足")]),v._v(" "),_("p",[v._v("4、CMS GC 时出现 promotion failed 和 concurrent mode failure")]),v._v(" "),_("p",[v._v("5、老年代空间分配担保机制 触发的时候；HandlePromotionFailure")]),v._v(" "),_("h2",{attrs:{id:"gc-垃圾回收算法和垃圾收集器的关系"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#gc-垃圾回收算法和垃圾收集器的关系"}},[v._v("#")]),v._v(" GC 垃圾回收算法和垃圾收集器的关系")]),v._v(" "),_("p",[v._v("垃圾回收算法：引用计数，复制，标记清除，标记整理")]),v._v(" "),_("p",[v._v("垃圾收集器：Serial，Parallel , CMS, G1")]),v._v(" "),_("p",[v._v("<1> Serial：串行收集器，为单线程环境设计且只使用一个线程进行垃圾回收，会暂停所有用户的线程，不适合服务器环境")]),v._v(" "),_("p",[v._v("<2> Parallel : 并行收集器，多个垃圾收集线程并行工作，用户线程是暂停的")]),v._v(" "),_("p",[v._v("<3> CMS：并发收集，用户线程和垃圾收集线程同时执行（互联网公司常用），缺点：CPU 压力大，会产生内存碎片")]),v._v(" "),_("p",[v._v("<4> G1：将堆内存分割成不同的区域，然后并发的对其进行垃圾回收")]),v._v(" "),_("h2",{attrs:{id:"_7-如何查看服务器默认的垃圾收集器是哪个-生产上如何配置"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-如何查看服务器默认的垃圾收集器是哪个-生产上如何配置"}},[v._v("#")]),v._v(" 7.如何查看服务器默认的垃圾收集器是哪个？生产上如何配置？")])])}),[],!1,null,null,null);_.default=r.exports}}]);