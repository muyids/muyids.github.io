(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{291:function(t,v,_){"use strict";_.r(v);var e=_(14),a=Object(e.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[t._v("操作系统有关知识点")]),t._v(" "),v("h2",{attrs:{id:"目录"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[t._v("#")]),t._v(" 目录")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B"}},[t._v("进程线程协程")])]),t._v(" "),v("li",[v("a",{attrs:{href:"#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"}},[t._v("线程调度算法")])]),t._v(" "),v("li",[v("a",{attrs:{href:"#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F"}},[t._v("进程通信的方式")])]),t._v(" "),v("li",[v("a",{attrs:{href:"#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"}},[t._v("页面置换算法")])]),t._v(" "),v("li",[v("a",{attrs:{href:"#epoll%E4%B8%8Eselect"}},[t._v("epoll 与 select")])]),t._v(" "),v("li",[v("a",{attrs:{href:"#%E6%AD%BB%E9%94%81"}},[t._v("死锁")])])]),t._v(" "),v("hr"),t._v(" "),v("h2",{attrs:{id:"进程线程协程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程线程协程"}},[t._v("#")]),t._v(" 进程线程协程")]),t._v(" "),v("ul",[v("li",[t._v("进程：资源分配的最小单位；操作系统会以进程为单位，分配系统资源（CPU 时间片、堆内存等资源）")]),t._v(" "),v("li",[t._v("线程：有时被称为轻量级进程(Lightweight Process，LWP），是操作系统调度（CPU 调度）执行的最小单位")]),t._v(" "),v("li",[t._v("协程：是由程序所控制，在用户态执行，是一种比线程更加轻量级的存在")])]),t._v(" "),v("h2",{attrs:{id:"线程调度算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程调度算法"}},[t._v("#")]),t._v(" 线程调度算法")]),t._v(" "),v("p",[t._v("cpu 调度算法")]),t._v(" "),v("ol",[v("li",[t._v("先来先服务(FCFS)")]),t._v(" "),v("li",[t._v("最短作业优先（SJF）")]),t._v(" "),v("li",[t._v("基于优先权的调度算法（FPPS）")]),t._v(" "),v("li",[t._v("时间片轮转（RR）")]),t._v(" "),v("li",[t._v("多级队列调度（Multilevel feedback queue）")])]),t._v(" "),v("h2",{attrs:{id:"进程通信的方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程通信的方式"}},[t._v("#")]),t._v(" 进程通信的方式")]),t._v(" "),v("h2",{attrs:{id:"epoll-与-select"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#epoll-与-select"}},[t._v("#")]),t._v(" epoll 与 select")]),t._v(" "),v("p",[t._v("select 基于轮询机制，epoll 基于通知机制，直接通知发生 IO 事件的 fd，select 需要在内核去和用户去不断拷贝 fd_set, epoll 采用共享内存机制，不需要，epoll 内核数据结构用的是红黑树，效率更高。")]),t._v(" "),v("h2",{attrs:{id:"死锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[t._v("#")]),t._v(" 死锁")]),t._v(" "),v("p",[t._v("产生条件 避免死锁 解除死锁")]),t._v(" "),v("ol",[v("li",[t._v("多线程和多进程的区别（重点   必须从 cpu 调度，上下文切换，数据共享，多核 cup 利用率，资源占用，等等各方面回答，然后有一个问题必须会被问到：哪些东西是一个线程私有的？答案中必须包含寄存器，否则悲催）！")])]),t._v(" "),v("p",[t._v("1）进程数据是分开的:共享复杂，需要用 IPC，同步简单；多线程共享进程数据：共享简单，同步复杂")]),t._v(" "),v("p",[t._v("2）进程创建销毁、切换复杂，速度慢 ；线程创建销毁、切换简单，速度快")]),t._v(" "),v("p",[t._v("3）进程占用内存多， CPU 利用率低；线程占用内存少， CPU 利用率高")]),t._v(" "),v("p",[t._v("4）进程编程简单，调试简单；线程 编程复杂，调试复杂")]),t._v(" "),v("p",[t._v("5）进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉")]),t._v(" "),v("p",[t._v("6）进程适应于多核、多机分布；线程适用于多核")]),t._v(" "),v("p",[t._v("线程所私有的：")]),t._v(" "),v("p",[t._v("线程 id、寄存器的值、栈、线程的优先级和调度策略、线程的私有数据、信号屏蔽字、errno 变量")]),t._v(" "),v("p",[t._v("2.  多线程锁的种类有哪些？")]),t._v(" "),v("p",[t._v("a.互斥锁（mutex）b.递归锁 c.自旋锁 d.读写锁")])])}),[],!1,null,null,null);v.default=a.exports}}]);