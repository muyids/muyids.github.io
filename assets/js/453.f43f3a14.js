(window.webpackJsonp=window.webpackJsonp||[]).push([[453],{729:function(v,_,t){"use strict";t.r(_);var e=t(14),l=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("操作系统有关知识点")]),v._v(" "),_("h2",{attrs:{id:"目录"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[v._v("#")]),v._v(" 目录")]),v._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"#%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B"}},[v._v("进程线程协程")])]),v._v(" "),_("li",[_("a",{attrs:{href:"#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"}},[v._v("线程调度算法")])]),v._v(" "),_("li",[_("a",{attrs:{href:"#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F"}},[v._v("进程通信的方式")])]),v._v(" "),_("li",[_("a",{attrs:{href:"#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"}},[v._v("页面置换算法")])]),v._v(" "),_("li",[_("a",{attrs:{href:"#epoll%E4%B8%8Eselect"}},[v._v("epoll 与 select")])]),v._v(" "),_("li",[_("a",{attrs:{href:"#%E6%AD%BB%E9%94%81"}},[v._v("死锁")])])]),v._v(" "),_("hr"),v._v(" "),_("h2",{attrs:{id:"进程线程协程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程线程协程"}},[v._v("#")]),v._v(" 进程线程协程")]),v._v(" "),_("ul",[_("li",[v._v("进程：资源分配的最小单位；操作系统会以进程为单位，分配系统资源（CPU 时间片、堆内存等资源）")]),v._v(" "),_("li",[v._v("线程：有时被称为轻量级进程(Lightweight Process，LWP），是操作系统调度（CPU 调度）执行的最小单位")]),v._v(" "),_("li",[v._v("协程：是由程序所控制，在用户态执行，是一种比线程更加轻量级的存在")])]),v._v(" "),_("h2",{attrs:{id:"线程调度算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程调度算法"}},[v._v("#")]),v._v(" 线程调度算法")]),v._v(" "),_("p",[v._v("cpu 调度算法")]),v._v(" "),_("ol",[_("li",[v._v("先来先服务(FCFS)")]),v._v(" "),_("li",[v._v("最短作业优先（SJF）")]),v._v(" "),_("li",[v._v("基于优先权的调度算法（FPPS）")]),v._v(" "),_("li",[v._v("时间片轮转（RR）")]),v._v(" "),_("li",[v._v("多级队列调度（Multilevel feedback queue）")])]),v._v(" "),_("h2",{attrs:{id:"进程通信的方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程通信的方式"}},[v._v("#")]),v._v(" 进程通信的方式")]),v._v(" "),_("h2",{attrs:{id:"epoll-与-select"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#epoll-与-select"}},[v._v("#")]),v._v(" epoll 与 select")]),v._v(" "),_("p",[v._v("select 基于轮询机制，epoll 基于通知机制，直接通知发生 IO 事件的 fd，select 需要在内核去和用户去不断拷贝 fd_set, epoll 采用共享内存机制，不需要，epoll 内核数据结构用的是红黑树，效率更高。")]),v._v(" "),_("p",[v._v("线程同步的方法：")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("互斥锁")])]),v._v(" "),_("li",[_("p",[v._v("读写锁")])]),v._v(" "),_("li",[_("p",[v._v("条件变量")])]),v._v(" "),_("li",[_("p",[v._v("信号量")])]),v._v(" "),_("li",[_("p",[v._v("自旋锁")])]),v._v(" "),_("li",[_("p",[v._v("屏障（barrier）")])])]),v._v(" "),_("h2",{attrs:{id:"死锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[v._v("#")]),v._v(" 死锁")]),v._v(" "),_("p",[v._v("产生条件 避免死锁 解除死锁")]),v._v(" "),_("p",[v._v("1.多线程和多进程的区别（重点   必须从 cpu 调度，上下文切换，数据共享，多核 cup 利用率，资源占用，等等各方面回答，然后有一个问题必须会被问到：哪些东西是一个线程私有的？答案中必须包含寄存器，否则悲催）！")]),v._v(" "),_("p",[v._v("1）进程数据是分开的:共享复杂，需要用 IPC，同步简单；多线程共享进程数据：共享简单，同步复杂")]),v._v(" "),_("p",[v._v("2）进程创建销毁、切换复杂，速度慢 ；线程创建销毁、切换简单，速度快")]),v._v(" "),_("p",[v._v("3）进程占用内存多， CPU 利用率低；线程占用内存少， CPU 利用率高")]),v._v(" "),_("p",[v._v("4）进程编程简单，调试简单；线程 编程复杂，调试复杂")]),v._v(" "),_("p",[v._v("5）进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉")]),v._v(" "),_("p",[v._v("6）进程适应于多核、多机分布；线程适用于多核")]),v._v(" "),_("p",[v._v("线程所私有的：")]),v._v(" "),_("p",[v._v("线程 id、寄存器的值、栈、线程的优先级和调度策略、线程的私有数据、信号屏蔽字、errno 变量")]),v._v(" "),_("p",[v._v("2.  多线程锁的种类有哪些？")]),v._v(" "),_("p",[v._v("a.互斥锁（mutex）b.递归锁 c.自旋锁 d.读写锁")]),v._v(" "),_("p",[v._v("3.  自旋锁和互斥锁的区别？")])])}),[],!1,null,null,null);_.default=l.exports}}]);