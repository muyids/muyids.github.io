(window.webpackJsonp=window.webpackJsonp||[]).push([[278],{551:function(v,_,s){"use strict";s.r(_);var a=s(14),t=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("https://blog.csdn.net/m0_37313888/article/details/105397939")]),v._v(" "),_("h3",{attrs:{id:"_1-能说下-myisam-和-innodb-的区别吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-能说下-myisam-和-innodb-的区别吗"}},[v._v("#")]),v._v(" 1.能说下 myisam 和 innodb 的区别吗")]),v._v(" "),_("ol",[_("li",[v._v("索引：innodb 是聚簇索引，myisam 是非聚簇索引")]),v._v(" "),_("li",[v._v("事务支持：innodb 支持，myisam 不支持")]),v._v(" "),_("li",[v._v("锁的粒度：INNODB 支持行锁和表锁，MYISAM 支持表锁")]),v._v(" "),_("li",[v._v("主键：INNODB 必须有，MYISAM 可以没有")]),v._v(" "),_("li",[v._v("外键：INNODB 支持外键")]),v._v(" "),_("li",[v._v("全文索引：MYIASM 支持")]),v._v(" "),_("li",[v._v("MVCC：INNODB 支持")])]),v._v(" "),_("h3",{attrs:{id:"说下-mysql-的索引有哪些吧-聚簇和非聚簇索引又是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#说下-mysql-的索引有哪些吧-聚簇和非聚簇索引又是什么"}},[v._v("#")]),v._v(" 说下 mysql 的索引有哪些吧，聚簇和非聚簇索引又是什么")]),v._v(" "),_("p",[v._v("索引按照数据结构来说主要包含 B+树和 Hash 索引。")]),v._v(" "),_("p",[v._v("假设我们有张表，结构如下：")]),v._v(" "),_("p",[v._v("create table user( id int(11) not null, age int(11) not null, primary key(id), key(age) );")]),v._v(" "),_("p",[v._v("B+树是左小右大的顺序存储结构，节点只包含 id 索引列，而叶子节点包含索引列和数据，这种数据和索引在一起存储的索引方式叫做聚簇索引，一张表只能有一个聚簇索引。假设没有定义主键，InnoDB 会选择一个唯一的非空索引代替，如果没有的话则会隐式定义一个主键作为聚簇索引。")]),v._v(" "),_("p",[v._v("这是主键聚簇索引存储的结构，那么非聚簇索引的结构是什么样子呢？非聚簇索引(二级索引)保存的是主键 id 值，这一点和 myisam 保存的是数据地址是不同的。")]),v._v(" "),_("h3",{attrs:{id:"什么是覆盖索引和回表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是覆盖索引和回表"}},[v._v("#")]),v._v(" 什么是覆盖索引和回表")]),v._v(" "),_("p",[v._v("覆盖索引指的是在一次查询中，如果一个索引包含或者说覆盖所有需要查询的字段的值，我们就称之为覆盖索引，而不再需要回表查询。")]),v._v(" "),_("p",[v._v("而要确定一个查询是否是覆盖索引，我们只需要 explain sql 语句看 Extra 的结果是否是“Using index”即可。")]),v._v(" "),_("h3",{attrs:{id:"锁的类型有哪些呢"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#锁的类型有哪些呢"}},[v._v("#")]),v._v(" 锁的类型有哪些呢")]),v._v(" "),_("p",[v._v("mysql 锁分为"),_("strong",[v._v("共享锁")]),v._v("和"),_("strong",[v._v("排他锁")]),v._v("，也叫做读锁和写锁。")]),v._v(" "),_("p",[v._v("读锁是共享的，可以通过 lock in share mode 实现，这时候只能读不能写。")]),v._v(" "),_("p",[v._v("写锁是排他的，它会阻塞其他的写锁和读锁。从颗粒度来区分，可以分为"),_("strong",[v._v("表锁")]),v._v("和"),_("strong",[v._v("行锁")]),v._v("两种。")]),v._v(" "),_("p",[v._v("表锁会锁定整张表并且阻塞其他用户对该表的所有读写操作，比如 alter 修改表结构的时候会锁表。")]),v._v(" "),_("p",[v._v("行锁又可以分为"),_("strong",[v._v("乐观锁")]),v._v("和"),_("strong",[v._v("悲观锁")]),v._v("，悲观锁可以通过 for update 实现，乐观锁则通过版本号实现。")]),v._v(" "),_("h3",{attrs:{id:"你能说下事务的基本特性和隔离级别吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#你能说下事务的基本特性和隔离级别吗"}},[v._v("#")]),v._v(" 你能说下事务的基本特性和隔离级别吗")]),v._v(" "),_("p",[v._v("事务基本特性 ACID 分别是：")]),v._v(" "),_("p",[_("strong",[v._v("原子性")]),v._v("指的是一个事务中的操作要么全部成功，要么全部失败。")]),v._v(" "),_("p",[_("strong",[v._v("一致性")]),v._v("指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如 A 转账给 B100 块钱，假设中间 sql 执行过程中系统崩溃 A 也不会损失 100 块，因为事务没有提交，修改也就不会保存到数据库。")]),v._v(" "),_("p",[_("strong",[v._v("隔离性")]),v._v("指的是一个事务的修改在最终提交前，对其他事务是不可见的。")]),v._v(" "),_("p",[_("strong",[v._v("持久性")]),v._v("指的是一旦事务提交，所做的修改就会永久保存到数据库中。")]),v._v(" "),_("p",[v._v("而隔离性有 4 个隔离级别，分别是：")]),v._v(" "),_("p",[_("strong",[v._v("read uncommit")]),v._v(" 读未提交，可能会读到其他事务未提交的数据，也叫做脏读。")]),v._v(" "),_("p",[v._v("用户本来应该读取到 id=1 的用户 age 应该是 10，结果读取到了其他事务还没有提交的事务，结果读取结果 age=20，这就是脏读。")]),v._v(" "),_("p",[_("strong",[v._v("read commit")]),v._v(" 读已提交，两次读取结果不一致，叫做不可重复读。")]),v._v(" "),_("p",[v._v("不可重复读解决了脏读的问题，他只会读取已经提交的事务。")]),v._v(" "),_("p",[v._v("用户开启事务读取 id=1 用户，查询到 age=10，再次读取发现结果=20，在同一个事务里同一个查询读取到不同的结果叫做不可重复读。")]),v._v(" "),_("p",[_("strong",[v._v("repeatable read")]),v._v(" 可重复复读，这是 mysql 的默认级别，就是每次读取结果都一样，但是有可能产生幻读。")]),v._v(" "),_("p",[_("strong",[v._v("serializable")]),v._v(" 串行化，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争的问题。")]),v._v(" "),_("h3",{attrs:{id:"_6-那-acid-靠什么保证的呢"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-那-acid-靠什么保证的呢"}},[v._v("#")]),v._v(" 6. 那 ACID 靠什么保证的呢")]),v._v(" "),_("p",[v._v("A 原子性：由 undo log 日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的 sql")]),v._v(" "),_("p",[v._v("C 一致性：一般由代码层面来保证")]),v._v(" "),_("p",[v._v("I 隔离性：由 MVCC 来保证")]),v._v(" "),_("p",[v._v("D 持久性：由内存+redo log 来保证，mysql 修改数据同时在内存和 redo log 记录这次操作，事务提交的时候通过 redo log 刷盘，宕机的时候可以从 redo log 恢复")]),v._v(" "),_("h3",{attrs:{id:"_7-那你说说什么是幻读-什么是-mvcc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-那你说说什么是幻读-什么是-mvcc"}},[v._v("#")]),v._v(" 7. 那你说说什么是幻读，什么是 MVCC")]),v._v(" "),_("p",[v._v("要说幻读，首先要了解 MVCC，MVCC 叫做多版本并发控制，实际上就是保存了数据在某个时间节点的快照。")]),v._v(" "),_("p",[v._v("我们每行数实际上隐藏了两列，创建时间版本号，过期(删除)时间版本号，每开始一个新的事务，版本号都会自动递增。")]),v._v(" "),_("h3",{attrs:{id:"那你知道什么是间隙锁吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#那你知道什么是间隙锁吗"}},[v._v("#")]),v._v(" 那你知道什么是间隙锁吗")]),v._v(" "),_("p",[v._v("间隙锁是可重复读级别下才会有的锁，结合 MVCC 和间隙锁可以解决幻读的问题。我们还是以 user 举例，假设现在 user 表有几条记录")]),v._v(" "),_("p",[v._v("当我们执行：")]),v._v(" "),_("p",[v._v("begin; select * from user where age=20 for update;")]),v._v(" "),_("p",[v._v("begin; insert into user(age) values(10); #成功 insert into user(age) values(11); #失败 insert into user(age) values(20); #失败 insert into user(age) values(21); #失败 insert into user(age) values(30); #失败")]),v._v(" "),_("p",[v._v("只有 10 可以插入成功，那么因为表的间隙 mysql 自动帮我们生成了区间(左开右闭)")]),v._v(" "),_("p",[v._v("(negative infinity，10],(10,20],(20,30],(30,positive infinity)")]),v._v(" "),_("p",[v._v("由于 20 存在记录，所以(10,20]，(20,30]区间都被锁定了无法插入、删除。")]),v._v(" "),_("p",[v._v("如果查询 21 呢？就会根据 21 定位到(20,30)的区间(都是开区间)。")]),v._v(" "),_("p",[v._v("需要注意的是唯一索引是不会有间隙索引的。")]),v._v(" "),_("h3",{attrs:{id:"你们数据量级多大-分库分表怎么做的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#你们数据量级多大-分库分表怎么做的"}},[v._v("#")]),v._v(" 你们数据量级多大？分库分表怎么做的？")]),v._v(" "),_("p",[v._v("首先分库分表分为垂直和水平两个方式，一般来说我们拆分的顺序是先垂直后水平。")]),v._v(" "),_("p",[_("strong",[v._v("垂直分库")])]),v._v(" "),_("p",[v._v("基于现在微服务拆分来说，都是已经做到了垂直分库了")]),v._v(" "),_("p",[_("strong",[v._v("垂直分表")])]),v._v(" "),_("p",[v._v("如果表字段比较多，将不常用的、数据较大的等等做拆分")]),v._v(" "),_("p",[_("strong",[v._v("水平分表")])]),v._v(" "),_("p",[v._v("首先根据业务场景来决定使用什么字段作为分表字段(sharding_key)，比如我们现在日订单 1000 万，我们大部分的场景来源于 C 端，我们可以用 user_id 作为 sharding_key，数据查询支持到最近 3 个月的订单，超过 3 个月的做归档处理，那么 3 个月的数据量就是 9 亿，可以分 1024 张表，那么每张表的数据大概就在 100 万左右。")]),v._v(" "),_("p",[v._v("比如用户 id 为 100，那我们都经过 hash(100)，然后对 1024 取模，就可以落到对应的表上了。")]),v._v(" "),_("h3",{attrs:{id:"那分表后的-id-怎么保证唯一性的呢"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#那分表后的-id-怎么保证唯一性的呢"}},[v._v("#")]),v._v(" 那分表后的 ID 怎么保证唯一性的呢？")]),v._v(" "),_("p",[v._v("因为我们主键默认都是自增的，那么分表之后的主键在不同表就肯定会有冲突了。有几个办法考虑：")]),v._v(" "),_("ol",[_("li",[v._v("分布式 ID，自己实现一套分布式 ID 生成算法或者使用开源的比如雪花算法这种")]),v._v(" "),_("li",[v._v("设定步长，比如 1-1024 张表我们分别设定 1-1024 的基础步长，这样主键落到不同的表就不会冲突了。")]),v._v(" "),_("li",[v._v("分表后不使用主键作为查询依据，而是每张表单独新增一个字段作为唯一主键使用，比如订单表订单号是唯一的，不管最终落在哪张表都基于订单号作为查询依据，更新也一样。")])]),v._v(" "),_("h3",{attrs:{id:"_11-分表后非-sharding-key-的查询怎么处理呢"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11-分表后非-sharding-key-的查询怎么处理呢"}},[v._v("#")]),v._v(" 11. 分表后非 sharding_key 的查询怎么处理呢？")]),v._v(" "),_("ol",[_("li",[v._v("打宽表，一般而言，商户端对数据实时性要求并不是很高，比如查询订单列表，可以把订单表同步到离线（实时）数仓，再基于数仓去做成一张宽表，再基于其他如 es 提供查询服务。")]),v._v(" "),_("li",[v._v("可以做一个 mapping 表，比如这时候商家要查询订单列表怎么办呢？不带 user_id 查询的话你总不能扫全表吧？所以我们可以做一个映射关系表，保存商家和用户的关系，查询的时候先通过商家查询到用户列表，再通过 user_id 去查询。")]),v._v(" "),_("li",[v._v("数据量不是很大的话，比如后台的一些查询之类的，也可以通过多线程扫表，然后再聚合结果的方式来做。或者异步的形式也是可以的。")])]),v._v(" "),_("h3",{attrs:{id:"说说-mysql-主从同步怎么做的吧"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#说说-mysql-主从同步怎么做的吧"}},[v._v("#")]),v._v(" 说说 mysql 主从同步怎么做的吧？")]),v._v(" "),_("p",[v._v("首先先了解 mysql 主从同步的原理")]),v._v(" "),_("ol",[_("li",[v._v("master 提交完事务后，写入 binlog")]),v._v(" "),_("li",[v._v("slave 连接到 master，获取 binlog")]),v._v(" "),_("li",[v._v("master 创建 dump 线程，推送 binglog 到 slave")]),v._v(" "),_("li",[v._v("slave 启动一个 IO 线程读取同步过来的 master 的 binlog，记录到 relay log 中继日志中")]),v._v(" "),_("li",[v._v("slave 再开启一个 sql 线程读取 relay log 事件并在 slave 执行，完成同步")]),v._v(" "),_("li",[v._v("slave 记录自己的 binglog\n"),_("img",{attrs:{src:"https://muyids.oss-cn-beijing.aliyuncs.com/v2-3f4098ddcf2173e707353e26ea68b657_r.jpg",alt:"v2-3f4098ddcf2173e707353e26ea68b657_r"}})])]),v._v(" "),_("p",[v._v("由于 mysql 默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，日志就丢失了。由此产生两个概念。")])])}),[],!1,null,null,null);_.default=t.exports}}]);