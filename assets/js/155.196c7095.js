(window.webpackJsonp=window.webpackJsonp||[]).push([[155],{428:function(v,_,n){"use strict";n.r(_);var o=n(14),t=Object(o.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("谈谈你对 AQS 的理解。AQS 如何实现可重入锁？")]),v._v(" "),_("p",[_("strong",[v._v("前言")])]),v._v(" "),_("p",[_("code",[v._v("AQS")]),v._v("是"),_("code",[v._v("JUC")]),v._v("最重要的基石")]),v._v(" "),_("p",[_("strong",[v._v("AQS 的概念")])]),v._v(" "),_("ul",[_("li",[v._v("抽象队列同步器 AbstractQueuedSynchronizer（以下简称同步器），并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础")]),v._v(" "),_("li",[v._v("用来构建锁或者其他同步组件的基础框架")]),v._v(" "),_("li",[v._v("两大核心属性：\n"),_("ul",[_("li",[v._v("成员变量 state：表示同步状态")]),v._v(" "),_("li",[v._v("内置的 FIFO 队列：实现资源获取线程的排队工作")])])])]),v._v(" "),_("p",[_("strong",[v._v("前置知识")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("Lock 接口")])]),v._v(" "),_("li",[_("p",[v._v("公平锁和非公平锁")])]),v._v(" "),_("li",[_("p",[v._v("可重入锁")])]),v._v(" "),_("li",[_("p",[v._v("LockSupport")])]),v._v(" "),_("li",[_("p",[v._v("自旋锁")])]),v._v(" "),_("li",[_("p",[v._v("数据结构之双向链表")])]),v._v(" "),_("li",[_("p",[v._v("模板设计模式\n"),_("strong",[v._v("Lock 接口是什么")])])])]),v._v(" "),_("p",[v._v("不同于 synchronized 关键字是 JVM 底层的锁机制实现，依赖于底层 C++实现；Lock 接口是 JUC 中 API 级别实现。")]),v._v(" "),_("p",[v._v("Lock 接口中定义了常用的锁方法：")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://muyids.oss-cn-beijing.aliyuncs.com/2021-09-08%20pm2.41.10.png",alt:"2021-09-08 pm2.41.10"}})]),v._v(" "),_("p",[v._v("其中有 4 个获取锁的方法，其中 lock 和 tryLock 是较为常用的：")]),v._v(" "),_("ul",[_("li",[v._v("lock() : 一直等，直到拿到锁")]),v._v(" "),_("li",[v._v("tryLock() : 只尝试一次，拿不到就放弃")]),v._v(" "),_("li",[v._v("tryLock(long time, TimeUnit unit) : 给定的时间内等待，超时就放弃")]),v._v(" "),_("li",[v._v("lockInterruptibly() : 通常情况下不会放弃，但如果外部有一个线程或方法将获取锁的方法中断，就不在获取锁了\n释放锁：unlock()")])]),v._v(" "),_("p",[v._v("创建监听器：newCondition(): 实现精准唤醒")]),v._v(" "),_("p",[_("strong",[v._v("可重入锁")])]),v._v(" "),_("p",[v._v("可以对一个对象多次执行 lock()加锁和 unlock()释放锁；")]),v._v(" "),_("p",[v._v("sychronized 和 reentrantLock 都是可重入锁")]),v._v(" "),_("p",[_("strong",[v._v("常用组件")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("重入锁 原来写游戏时候锁血量用")])]),v._v(" "),_("li",[_("p",[v._v("写分布式缓存时候 用过 readWriteLock 来保证性能和 数据一致性")])]),v._v(" "),_("li",[_("p",[v._v("countDownLatch 在艺龙机票查询几十个供应商时候用，一个请求拆分成多个")])]),v._v(" "),_("li",[_("p",[v._v("SemaPhore 在写分布式缓存的时候 在首次加载资源的时候限制突发量的，只允许前 10 个线程来加载几个")])])]),v._v(" "),_("p",[v._v("CountdownLatch 和 cyclicBarrier 区别")]),v._v(" "),_("ul",[_("li",[v._v("cdl 是主线程分成多个子线程最后回到主线程")]),v._v(" "),_("li",[v._v("cycB 是主线程分成多个子线程最后回调一个分线程")]),v._v(" "),_("li",[v._v("cyclicBarrier 可以循环调用")])]),v._v(" "),_("p",[v._v("ReadWriteLock 读写锁")]),v._v(" "),_("p",[_("strong",[v._v("ReentrantLock")])]),v._v(" "),_("p",[v._v("这里经常有一个扩展问题，"),_("strong",[v._v("Sychronized 和 ReentrantLock 的区别")]),v._v("，我们一般会从以下方面回答")]),v._v(" "),_("ul",[_("li",[v._v("sychronized 是⼀个关键字，ReentrantLock 是⼀个类")]),v._v(" "),_("li",[v._v("sychronized 的底层是 JVM 层⾯的锁，ReentrantLock 是 API 层⾯的锁")]),v._v(" "),_("li",[v._v("sychronized 会⾃动的加锁与释放锁，ReentrantLock 需要程序员⼿动加锁与释放锁")]),v._v(" "),_("li",[v._v("sychronized 是⾮公平锁，ReentrantLock 可以选择公平锁或⾮公平锁")]),v._v(" "),_("li",[v._v("sychronized 锁的是对象，锁信息保存在对象头中，ReentrantLock 通过代码中 int 类型的 state 标识来标识锁的状态")]),v._v(" "),_("li",[v._v("sychronized 底层有⼀个锁升级的过程")]),v._v(" "),_("li",[v._v("synchronized 适合"),_("strong",[v._v("锁的少量代码")]),v._v("，lock 适合"),_("strong",[v._v("大量锁")]),v._v("的代码")])]),v._v(" "),_("p",[_("strong",[v._v("手写一个 ReentrantLock")])]),v._v(" "),_("p",[_("strong",[v._v("AQS 尾分叉")])]),v._v(" "),_("p",[_("strong",[v._v("ReadWriteRock 读写锁")]),v._v("，使用场景可分为读/读、读/写、写/写，除了读和读之间是共享的，其它都是互斥的，接着会讨论下怎样实现互斥锁和同步锁的， 想了解对方对 AQS，CAS 的掌握程度，技术学习的深度。")]),v._v(" "),_("p",[_("strong",[v._v("Semaphore 拿到执行权的线程之间是否互斥")]),v._v("，Semaphore、CountDownLatch、CyclicBarrier、Exchanger 为 java 并发编程的 4 个辅助类，面试中常问的 CountDownLatch CyclicBarrier 之间的区别，面试者肯定是经常碰到的， 所以问起来意义不大，Semaphore 问的相对少一些，有些知识点如果没有使用过还是会忽略，Semaphore 可有多把锁，可允许多个线程同时拥有执行权，这些有执行权的线程如并发访问同一对象，会产生线程安全问题。")]),v._v(" "),_("p",[v._v("作者：Mingdeng Yue\n链接：https://www.zhihu.com/question/60949531/answer/579002882\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n"),_("strong",[v._v("CountDownLatch 和 Semaphore 的区别和底层原理")])]),v._v(" "),_("p",[v._v("CountDownLatch 表示计数器，可以给 CountDownLatch 设置⼀个数字，⼀个线程调⽤")]),v._v(" "),_("p",[v._v("CountDownLatch 的 await()将会阻塞，其他线程可以调⽤ CountDownLatch 的 countDown()⽅法来对")]),v._v(" "),_("p",[v._v("CountDownLatch 中的数字减⼀，当数字被减成 0 后，所有 await 的线程都将被唤醒。")]),v._v(" "),_("p",[v._v("对应的底层原理就是，调⽤ await()⽅法的线程会利⽤ AQS 排队，⼀旦数字被减为 0，则会将 AQS 中")]),v._v(" "),_("p",[v._v("排队的线程依次唤醒。")]),v._v(" "),_("p",[v._v("Semaphore 表示信号量，可以设置许可的个数，表示同时允许最多多少个线程使⽤该信号量，通")]),v._v(" "),_("p",[v._v("过 acquire()来获取许可，如果没有许可可⽤则线程阻塞，并通过 AQS 来排队，可以通过 release()")]),v._v(" "),_("p",[v._v("⽅法来释放许可，当某个线程释放了某个许可后，会从 AQS 中正在排队的第⼀个线程开始依次唤")]),v._v(" "),_("p",[v._v("醒，直到没有空闲许可。")]),v._v(" "),_("p",[v._v("思考下面的问题怎么回答")]),v._v(" "),_("ul",[_("li",[v._v("ReentrantLock 中的公平锁和⾮公平锁的底层实现")]),v._v(" "),_("li",[v._v("ReentrantLock 中 tryLock()和 lock()⽅法的区别")]),v._v(" "),_("li",[v._v("CountDownLatch 和 Semaphore 的区别和底层原理")]),v._v(" "),_("li",[v._v("Sychronized 和 ReentrantLock 的区别\n总结")])]),v._v(" "),_("ol",[_("li",[v._v("AQS 抽象队列同步器，是 java 的线程同步框架，是 JDK 中很多锁工具的核心实现框架")]),v._v(" "),_("li",[v._v("AQS 中维护了一个信号量 state 和一个线程组成的双向链表队列")])])])}),[],!1,null,null,null);_.default=t.exports}}]);