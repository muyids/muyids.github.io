(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{282:function(e,s,a){"use strict";a.r(s);var t=a(14),_=Object(t.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("我们经常遇到的一种业务场景：完成 A 事件后，过一定时间，去做 B 事件；这种场景应该如何处理？")]),e._v(" "),s("h2",{attrs:{id:"定时任务分为两种"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#定时任务分为两种"}},[e._v("#")]),e._v(" 定时任务分为两种")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("一种最简单的定时任务")]),e._v(" "),s("p",[e._v("比如说每天凌晨三点自动运行起来跑一个脚本，这种一个 "),s("code",[e._v("Crontab")]),e._v(" 任务 就能搞定。")])]),e._v(" "),s("li",[s("p",[e._v("另一种是计时器任务\n比如用户触发了某个动作，那么从这个点开始过 二十四 小时 我们要对这个动作做点什么。那么如果有 1000 个用户触发了这个动作，就会有 1000 个定时任务。\n计时器任务业务场景举例")])]),e._v(" "),s("li",[s("p",[e._v("用户注册 2 个小时后给用户发送短信")])]),e._v(" "),s("li",[s("p",[e._v("15 分钟后关闭网络连接")])]),e._v(" "),s("li",[s("p",[e._v("2 分钟后再次尝试回调")])])]),e._v(" "),s("h2",{attrs:{id:"基于轮训实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基于轮训实现"}},[e._v("#")]),e._v(" 基于轮训实现")]),e._v(" "),s("p",[e._v("常见的实现方式是轮训业务表，每隔一定时间间隔查询业务表")]),e._v(" "),s("p",[e._v("缺点")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("轮询效率比较低")]),e._v(" "),s("p",[e._v("当业务量比较大时，时间轮训会存在效率问题")])]),e._v(" "),s("li",[s("p",[e._v("存在时间误差\n如果轮训间隔为一小时，误差最大即一小时\n如何在保证效率的同时保证实时性？")])])]),e._v(" "),s("h2",{attrs:{id:"基于-redis-的键空间消息"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基于-redis-的键空间消息"}},[e._v("#")]),e._v(" 基于 redis 的键空间消息")]),e._v(" "),s("p",[e._v("在 redis 2.8.0 版本之后，推出了一个新的特性键空间消息（Redis Keyspace Notifications），配合 2.0.0 版本的 SUBSCRIBE 就能完成计时器任务。")]),e._v(" "),s("h3",{attrs:{id:"keyspace-notifications"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#keyspace-notifications"}},[e._v("#")]),e._v(" Keyspace Notifications")]),e._v(" "),s("p",[e._v("所谓的键空间通知，即是当某个键过期或者被修改时，会触发特定事件，并向订阅了该事件对应的通道推送消息。")]),e._v(" "),s("p",[e._v("默认情况下对于每个修改数据库的操作，键空间通知都会发送两种不同类型的事件。")]),e._v(" "),s("p",[e._v("比如说，对 0 号数据库的键 mykey 执行 DEL 命令时， 系统将分发两条消息， 相当于执行以下两个 PUBLISH 命令：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("PUBLISH __keyspace@0__:mykey del\nPUBLISH __keyevent@0__:del mykey\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("p",[e._v("订阅第一个频道 keyspace@0:mykey 可以接收 0 号数据库中所有修改键 mykey 的事件，而订阅第二个频道 keyevent@0:del 则可以接收 0 号数据库中所有执行 del 命令的键。")]),e._v(" "),s("p",[e._v("以 keyspace 为前缀的频道被称为键空间通知（keyspace notification），而以 keyevent 为前缀的频道则被称为键事件通知（keyevent notification）。")]),e._v(" "),s("p",[e._v("当"),s("code",[e._v("del mykey")]),e._v("命令执行时：")]),e._v(" "),s("ul",[s("li",[e._v("键空间频道的订阅者将接收到被执行的事件的名字，在这个例子中，就是 del 。")]),e._v(" "),s("li",[e._v("键事件频道的订阅者将接收到被执行事件的键的名字，在这个例子中，就是 mykey 。")])]),e._v(" "),s("h3",{attrs:{id:"启用-keyspace-notifications"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#启用-keyspace-notifications"}},[e._v("#")]),e._v(" 启用 Keyspace Notifications")]),e._v(" "),s("p",[e._v("因为开启键空间通知功能需要消耗一些 CPU ，所以在默认配置下，该功能处于关闭状态。")]),e._v(" "),s("p",[e._v("可以通过修改 "),s("code",[e._v("redis.conf")]),e._v(" 文件， 或者直接使用 "),s("code",[e._v("CONFIG SET")]),e._v(" 命令来开启或关闭键空间通知功能：")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("当 notify-keyspace-events 选项的参数为空字符串时，功能关闭。")])]),e._v(" "),s("li",[s("p",[e._v("另一方面，当参数不是空字符串时，功能开启。\nnotify-keyspace-events 的参数可以是以下字符的任意组合， 它指定了服务器该发送哪些类型的通知")])]),e._v(" "),s("li",[s("p",[e._v("K，表示 keyspace 事件，有这个字母表示会往 keyspace@ 频道推消息。")])]),e._v(" "),s("li",[s("p",[e._v("E，表示 keyevent 事件，有这个字母表示会往 keyevent@ 频道推消息。")])]),e._v(" "),s("li",[s("p",[e._v("g，表示一些通用指令事件支持，如 DEL、EXPIRE、RENAME 等等。")])]),e._v(" "),s("li",[s("p",[e._v("$，表示字符串（String）相关指令的事件支持。")])]),e._v(" "),s("li",[s("p",[e._v("l，表示列表（List）相关指令事件支持。")])]),e._v(" "),s("li",[s("p",[e._v("s，表示集合（Set）相关指令事件支持。")])]),e._v(" "),s("li",[s("p",[e._v("h，哈希（Hash）相关指令事件支持。")])]),e._v(" "),s("li",[s("p",[e._v("z，有序集（Sorted Set）相关指令事件支持。")])]),e._v(" "),s("li",[s("p",[e._v("x，过期事件，与 g 中的 EXPIRE 不同的是，g 的 EXPIRE 是指执行 EXPIRE key ttl 这条指令的时候顺便触发的事件，而这里是指那个 key 刚好过期的这个时间点触发的事件。")])]),e._v(" "),s("li",[s("p",[e._v("e，驱逐事件，一个 key 由于内存上限而被驱逐的时候会触发的事件。")])]),e._v(" "),s("li",[s("p",[e._v("A，g$lshzxe 的别名。也就是说 AKE 的意思就代表了所有的事件。")])])]),e._v(" "),s("p",[e._v("由于上文的需求，只需设置值为 Ex 就能满足。")]),e._v(" "),s("p",[e._v("直接修改 redis.conf 文件"),s("code",[e._v("notify-keyspace-events Ex")]),e._v(", 或使用如下命令")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("$ redis-cli config set notify-keyspace-events KEA\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("h3",{attrs:{id:"动手实践"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#动手实践"}},[e._v("#")]),e._v(" 动手实践")]),e._v(" "),s("p",[e._v("配置完后，重启 redis 服务后，测试如下:")]),e._v(" "),s("p",[e._v("启动一个客户端，对 0 号数据库订阅过期键事件通知")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('127.0.0.1:6379> SUBSCRIBE __keyevent@0__:expired\nReading messages... (press Ctrl-C to quit)\n1) "subscribe"\n2) "__keyevent@0__:expired"\n3) (integer) 1\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br")])]),s("p",[e._v("启动另一个客户端，设置 mykey 值为 hh 过期时间为 5 秒")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("127.0.0.1:6379> SET mykey hh EX 5\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("5 秒后查看之前的客户端显示")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('127.0.0.1:6379> SUBSCRIBE __keyevent@0__:expired\nReading messages... (press Ctrl-C to quit)\n1) "subscribe"\n2) "__keyevent@0__:expired"\n3) (integer) 1\n1) "message"\n2) "__keyevent@0__:expired"\n3) "mykey"\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br")])]),s("h3",{attrs:{id:"优点与缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优点与缺点"}},[e._v("#")]),e._v(" 优点与缺点")]),e._v(" "),s("h4",{attrs:{id:"优点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[e._v("#")]),e._v(" 优点")]),e._v(" "),s("ul",[s("li",[e._v("被动接受消息，相对于主动轮询被动接受效率更高。")]),e._v(" "),s("li",[e._v("数据持久化，进程重启时任务数据不会丢失。")]),e._v(" "),s("li",[e._v("跨进程通信，设置任务方和订阅消息方可以是不同进程。")]),e._v(" "),s("li",[e._v("高效的第三方数据维护，内存管理更高效，解决了 node 单进程内存上限的问题。")])]),e._v(" "),s("h4",{attrs:{id:"缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[e._v("#")]),e._v(" 缺点")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("超时事件通知到达时，如何获取已超时的值")]),e._v(" "),s("p",[e._v("当 key 超时，被删除，此时如何获取 key 对应的 value，进行业务操作？")]),e._v(" "),s("p",[s("a",{attrs:{href:"http://stackoverflow.com/questions/18328058/redis-2-8-notifications-get-value-instead-of-key-on-expire",target:"_blank",rel:"noopener noreferrer"}},[e._v("Redis 2.8 notifications: Get value instead of key (on expire)"),s("OutboundLink")],1)])]),e._v(" "),s("li",[s("p",[e._v("如果 redis 宕机，keyspace 的所有记录将无法保存，计时器任务将会丢失，健壮性有待提高")])])]),e._v(" "),s("h2",{attrs:{id:"时间轮算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#时间轮算法"}},[e._v("#")]),e._v(" 时间轮算法")]),e._v(" "),s("p",[e._v("系统设计：对于 50 万个客户端的 websocket 连接，服务端要主动关闭 60 秒以上没有活动的连接，如何设计？")]),e._v(" "),s("p",[e._v("这是一个拟问题，一般单机 50 万连接是不太可能的，主要考察我们对业务场景的分析。")]),e._v(" "),s("h3",{attrs:{id:"心跳"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#心跳"}},[e._v("#")]),e._v(" 心跳")]),e._v(" "),s("p",[e._v("方案不可取，性能太低，超时")]),e._v(" "),s("h3",{attrs:{id:"有序链表-lru"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#有序链表-lru"}},[e._v("#")]),e._v(" 有序链表 LRU")]),e._v(" "),s("h3",{attrs:{id:"时间堆"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#时间堆"}},[e._v("#")]),e._v(" 时间堆")]),e._v(" "),s("h3",{attrs:{id:"时间轮"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#时间轮"}},[e._v("#")]),e._v(" 时间轮")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"http://redis.io/topics/notifications",target:"_blank",rel:"noopener noreferrer"}},[e._v("Redis Keyspace Notifications"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"http://zhangyp.net/rabbitmq-delayqueue/",target:"_blank",rel:"noopener noreferrer"}},[e._v("rabbitmq-delayqueue"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=_.exports}}]);