(window.webpackJsonp=window.webpackJsonp||[]).push([[165],{439:function(v,_,a){"use strict";a.r(_);var t=a(14),s=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("观看笔记")]),v._v(" "),_("p",[v._v("https://www.bilibili.com/video/BV1F64y1B7sV")]),v._v(" "),_("h4",{attrs:{id:"内存模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内存模型"}},[v._v("#")]),v._v(" 内存模型")]),v._v(" "),_("p",[v._v("![2021-11-08 pm5.08.52](https://muyids.oss-cn-beijing.aliyuncs.com/2021-11-08 pm5.08.52.png)")]),v._v(" "),_("h4",{attrs:{id:"硬件内存模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#硬件内存模型"}},[v._v("#")]),v._v(" "),_("strong",[v._v("硬件内存模型")])]),v._v(" "),_("p",[v._v("cpu 寄存器 -> L1/L2/L3 级缓存 -> 主存")]),v._v(" "),_("p",[v._v("cpu 由单核发展成多核，会存在多个 cpu 同时修改内存中的数据，导致 cpu 中的缓存出现不一致的问题")]),v._v(" "),_("p",[v._v("![2021-11-08 pm3.54.46](https://muyids.oss-cn-beijing.aliyuncs.com/2021-11-08 pm3.54.46.png)")]),v._v(" "),_("h4",{attrs:{id:"缓存一致性协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存一致性协议"}},[v._v("#")]),v._v(" "),_("strong",[v._v("缓存一致性协议")])]),v._v(" "),_("p",[v._v("CPU 缓存一致性协议，大致分为两类：")]),v._v(" "),_("ul",[_("li",[v._v("窥探型")]),v._v(" "),_("li",[v._v("基于目录型\n当 cpu 缓存想要访问主存时，需要经过一致性协议这种"),_("strong",[v._v("软件层面")]),v._v("的措施，来保证数据的一致性；")])]),v._v(" "),_("p",[v._v("（协议本事的实现细节这里不再发散的去展开，自行搜索：）")]),v._v(" "),_("p",[v._v("协议的内容一定是和数据同步相关的操作，既然是数据同步很可能出现 "),_("strong",[v._v("等待、唤醒")]),v._v("等操作，会出现性能问题，尤其是对 cpu 这种运算速度极快的组件来说，丝毫的等待都是极大的浪费。")]),v._v(" "),_("h4",{attrs:{id:"指令重排序"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#指令重排序"}},[v._v("#")]),v._v(" "),_("strong",[v._v("指令重排序")])]),v._v(" "),_("p",[v._v("于是计算机科学家对 cpu 的读写做了一定的优化，主要就是把同步改为了异步，比如 cpuA 改写数据 D，cpuB 读取 D，发现正在被 cpuA 改写，就注册一个事件，然后 cpuB 去做其他的事情，数据 D 改写完毕后，响应消息，cpuB 继续处理；")]),v._v(" "),_("p",[v._v("但是改为异步模型，对 cpuB 来说，指令看上去就不是顺序执行的了，这时就需要"),_("strong",[v._v("指令重排序")]),v._v("，保证指令集执行的结果是一致的")]),v._v(" "),_("h4",{attrs:{id:"java-内存模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java-内存模型"}},[v._v("#")]),v._v(" "),_("strong",[v._v("java 内存模型")])]),v._v(" "),_("p",[v._v("硬件内存模型的目标是为了让汇编代码能运行在一个具有"),_("strong",[v._v("一致性的内存视图")]),v._v("上；")]),v._v(" "),_("p",[v._v("随着高级语言的流行，工程师们开始设计编程语言级别的内存模型，这是为了让大家在使用高级语言时，也能具有一个具有一致性的内存视图；比如 java 内存模型；可以屏蔽各种硬件和操作系统的内存访问差异；")]),v._v(" "),_("p",[v._v("![2021-11-08 pm4.12.08](https://muyids.oss-cn-beijing.aliyuncs.com/2021-11-08 pm4.12.08.png)")]),v._v(" "),_("p",[v._v("具体一点，就是 把工作线程和本地内存具象为 thread stack，把主存具象为 heap。")]),v._v(" "),_("p",[v._v("thread stack 中的两种类型变量： 原始类型变量（比如 int，char 等）总是存储在线程栈上；对象类型的变量，引用存储在线程栈上，引用指向的对象存储在 heap 上；")]),v._v(" "),_("p",[v._v("heap 作为全局共享空间；存储对象本身，并不关心哪个线程正在访问对象；")]),v._v(" "),_("p",[v._v("我们可以这样理解，java 线程模型中的 thread stack 和 heap 都是对物理内存的一种抽象；这样开发者只需要关心自己的程序使用了 thread stack 和 heap 而不需要关心更下层的寄存器，cpu 缓存，主存等等；")]),v._v(" "),_("p",[v._v("![2021-11-08 pm3.35.10](https://muyids.oss-cn-beijing.aliyuncs.com/2021-11-08 pm3.35.10-6359951.png)")]),v._v(" "),_("p",[_("strong",[v._v("（1）JVM 内存模型将内存分为 5 个区：")])]),v._v(" "),_("p",[v._v("栈区（java 虚拟机栈），堆区")]),v._v(" "),_("p",[v._v("本地方法栈，程序计数器，方法区（元空间）")]),v._v(" "),_("p",[_("strong",[v._v("（2）各个区各自的作用：")])]),v._v(" "),_("p",[v._v("d. Java 虚拟机栈：用于存储局部变量，对象地址\ne.堆：对象实例\na. 本地方法栈：存放 C++的 native 方法的栈区\nb. 程序计数器：记录各个线程执行的字节码的行号\nc. 元数据区（方法区）：类加载器 class loader 信息、常量、静态变量")]),v._v(" "),_("p",[_("strong",[v._v("（3）线程私有、公有")])]),v._v(" "),_("p",[v._v("a.线程私有：每个线程在开辟、运行的过程中会单独创建这样的一份内存，有多少个线程可能有多少个内存")]),v._v(" "),_("p",[_("strong",[v._v("Java 虚拟机栈、本地方法栈、程序计数器是线程私有的")])]),v._v(" "),_("p",[v._v("b.线程全局共享的")]),v._v(" "),_("p",[v._v("堆和方法区")]),v._v(" "),_("p",[_("strong",[v._v("（4）GC")])]),v._v(" "),_("p",[v._v("栈虽然方法运行完毕了之后被清空了，但是堆上面的还没有被清空，所以引出了 GC（垃圾回收），不能立马删除，因为不知道是否还有其它的也是引用了当前的地址来访问的")]),v._v(" "),_("h4",{attrs:{id:"线程通信"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程通信"}},[v._v("#")]),v._v(" "),_("strong",[v._v("线程通信")])]),v._v(" "),_("p",[v._v("通过八个 内存读写指令，线程 A 将数据写入主存，线程 B 从主存中读取数据，实现线程中的通信")]),v._v(" "),_("h4",{attrs:{id:"线程通信存在的问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程通信存在的问题"}},[v._v("#")]),v._v(" 线程通信存在的问题")]),v._v(" "),_("p",[v._v("可见性：一个线程修改变量时，其他线程能够立刻得知修改；线程 A 写入了数据 d，线程 B 需要能够接收到数据 d 的修改")]),v._v(" "),_("p",[v._v("原子性：要么成功，要么失败；单指令原子性；多指令原子性；")]),v._v(" "),_("p",[v._v("有序性：指令重排序：单线程模型中，无论指令如何重排，都能保证和顺序执行的结果是一致的")]),v._v(" "),_("h4",{attrs:{id:"volatile-关键字"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#volatile-关键字"}},[v._v("#")]),v._v(" volatile 关键字")]),v._v(" "),_("p",[v._v("可见性：主动请求主存")]),v._v(" "),_("p",[v._v("禁止指令重排序:")]),v._v(" "),_("h4",{attrs:{id:"happens-before-原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#happens-before-原则"}},[v._v("#")]),v._v(" Happens-Before 原则")]),v._v(" "),_("p",[v._v("对于两个操作 A 和 B，在不同线程中执行，如果 A Happens-Before B（A 先于 B 执行）；可以保证 A 执行完毕后，执行结果对 B 是可见的")]),v._v(" "),_("p",[v._v("规则：")]),v._v(" "),_("ol",[_("li",[v._v("程序顺序规则")]),v._v(" "),_("li",[v._v("锁定规则")]),v._v(" "),_("li",[v._v("volatile 变量规则")]),v._v(" "),_("li",[v._v("...")])])])}),[],!1,null,null,null);_.default=s.exports}}]);